<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.57.2" />
    <meta name="description" content="">


    <link rel="icon" href="/images/favicon.png" type="image/png">

    <title>C11: Sequential Data :: Bamboofx&#39;s or NTVFX&#39;s Site</title>

    
    <link href="/css/nucleus.css?1576139178" rel="stylesheet">
    <link href="/css/fontawesome-all.min.css?1576139178" rel="stylesheet">
    <link href="/css/hybrid.css?1576139178" rel="stylesheet">
    <link href="/css/featherlight.min.css?1576139178" rel="stylesheet">
    <link href="/css/perfect-scrollbar.min.css?1576139178" rel="stylesheet">
    <link href="/css/auto-complete.css?1576139178" rel="stylesheet">
    <link href="/css/atom-one-dark-reasonable.css?1576139178" rel="stylesheet">
    <link href="/css/theme.css?1576139178" rel="stylesheet">
    <link href="/css/hugo-theme.css?1576139178" rel="stylesheet">
    
      <link href="/css/theme-blue.css?1576139178" rel="stylesheet">
    

    <script src="/js/jquery-3.3.1.min.js?1576139178"></script>

    <style>
      :root #header + #content > #left > #rlblock_left{
          display:none !important;
      }
      
    </style>
    
  </head>
  <body class="" data-url="/ai-with-python/chapter11/">
    <nav id="sidebar" class="">



  <div id="header-wrapper">
    <div id="header">
      <a id="logo" href="https://bamboofx.github.io/">
  <img src="https://bamboofx.github.io/images/logo.png "> </img>
</a>

    </div>
    
        <div class="searchbox">
    <label for="search-by"><i class="fas fa-search"></i></label>
    <input data-search-input id="search-by" type="search" placeholder="Search...">
    <span data-search-clear=""><i class="fas fa-times"></i></span>
</div>

<script type="text/javascript" src="/js/lunr.min.js?1576139178"></script>
<script type="text/javascript" src="/js/auto-complete.js?1576139178"></script>
<script type="text/javascript">
    
        var baseurl = "https:\/\/bamboofx.github.io\/";
    
</script>
<script type="text/javascript" src="/js/search.js?1576139178"></script>

    
  </div>

    <div class="highlightable">
    <ul class="topics">

        
          
          


 
  
    
    <li data-nav-id="/ai-with-python/" title="AI with Python (Prateek Joshi)" class="dd-item 
        parent
        
        
        ">
      <a href="/ai-with-python/">
          AI with Python (Prateek Joshi)
          
      </a>
      
      
        <ul>
          
          
          
          
        
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter1/" title="C1: Trí thông minh nhân tạo là gì?" class="dd-item ">
        <a href="/ai-with-python/chapter1/">
        C1: Trí thông minh nhân tạo là gì?
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter2/" title="C2: Classification and Regression" class="dd-item ">
        <a href="/ai-with-python/chapter2/">
        C2: Classification and Regression
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter3/" title="C3: Ensemble Learing" class="dd-item ">
        <a href="/ai-with-python/chapter3/">
        C3: Ensemble Learing
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter4/" title="C4: Detecting Patterns with Unsupervised Learning" class="dd-item ">
        <a href="/ai-with-python/chapter4/">
        C4: Detecting Patterns with Unsupervised Learning
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter5/" title="C5: Building Recommender Systems" class="dd-item ">
        <a href="/ai-with-python/chapter5/">
        C5: Building Recommender Systems
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter6/" title="C6: Logic Programing" class="dd-item ">
        <a href="/ai-with-python/chapter6/">
        C6: Logic Programing
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter7/" title="C7: Tìm kiếm Heuristic" class="dd-item ">
        <a href="/ai-with-python/chapter7/">
        C7: Tìm kiếm Heuristic
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter8/" title="C8: Thuật toán di truyền - Genetic Alogrithms" class="dd-item ">
        <a href="/ai-with-python/chapter8/">
        C8: Thuật toán di truyền - Genetic Alogrithms
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter9/" title="C9: Xây dựng game cùng với AI" class="dd-item ">
        <a href="/ai-with-python/chapter9/">
        C9: Xây dựng game cùng với AI
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter10/" title="C10: Natural Language Processing" class="dd-item ">
        <a href="/ai-with-python/chapter10/">
        C10: Natural Language Processing
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter11/" title="C11: Sequential Data" class="dd-item active">
        <a href="/ai-with-python/chapter11/">
        C11: Sequential Data
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter12/" title="C12: Speech Recognizer" class="dd-item ">
        <a href="/ai-with-python/chapter12/">
        C12: Speech Recognizer
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter13/" title="C13: Object Detection and Tracking" class="dd-item ">
        <a href="/ai-with-python/chapter13/">
        C13: Object Detection and Tracking
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
              
    </li>
  
 

          
          


 
  
    
    <li data-nav-id="/numpy/" title="NumPy cơ bản" class="dd-item 
        
        
        
        ">
      <a href="/numpy/">
          NumPy cơ bản
          
      </a>
      
              
    </li>
  
 

          
          


 
  
    
    <li data-nav-id="/about/" title="about" class="dd-item 
        
        
        
        ">
      <a href="/about/">
          About
          
      </a>
      
              
    </li>
  
 

          
         
    </ul>

    
    

    
    <section id="footer">
      <p>Built with <a href="https://github.com/matcornic/hugo-theme-learn"><i class="fas fa-heart"></i></a> from <a href="https://getgrav.org">Grav</a> and <a href="https://gohugo.io/">Hugo</a></p>

    </section>
  </div>
</nav>





        <section id="body">
        <div id="overlay"></div>
        <div class="padding highlightable">
              
              <div>
                <div id="top-bar">
                
                
                <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                    <span id="sidebar-toggle-span">
                        <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                          <i class="fas fa-bars"></i>
                        </a>
                    </span>
                  
                  <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
                  
                  <span class="links">
                 
                 
                    
          
          
            
            
          
          
            
            
          
          
            <a href='/'>Site</a> > <a href='/ai-with-python/'>AI with Python (Prateek Joshi)</a> > C11: Sequential Data
          
         
          
         
          
        
                 
                  </span>
                </div>
                
                    <div class="progress">
    <div class="wrapper">

    </div>
</div>

                
              </div>
            </div>
            
        <div id="head-tags">
        
        </div>
        
        <div id="body-inner">
          
            <h1>
              
              C11: Sequential Data
            </h1>
          

        



<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>PythonAI Chapter11</title></head><body><div class="calibre" id="calibre_link-0">
	<p class="block_">11</p>
	<p class="block_">Lý luận xác suất cho dữ liệu liên tục</p>
	<p class="block_1">Trong chương này chúng ta sẽ học về cách xây dựng một mô hình học liên tục. Chúng ta sẽ học cách xử lý dữ liệu chuỗi trong Pandas. Chúng ta sẽ biết được cách chia dữ liệu chuỗi và biểu diễn hoạt động của nó. Chúng ta sẽ thảo luận về cách tách những số liệu thống kê khác nhau từ một dữ liệu chuỗi. Chúng ta sẽ học về mô hình <b class="calibre1">Hidden Markov </b> và áp dụng nó vào một hệ thống để xây dựng các mô hình. Chúng ta sẽ hiểu cach sử dụng Conditional Random Fields để phân tích trình tự của bảng chữ cái. Chúng ta sẽ thảo luận cách phấn tích dữ liệu chứng khoán sử dụng những kỹ thuật sẽ học:</p>
	<ul class="list_">
	<li class="block_2">Quản lý dữ liệu chuỗi với Pandas</li>
	<li class="block_3">Chia dữ liệu chuỗi</li>
	<li class="block_3">Các phép tính trên dữ liệu chuỗi</li>
	<li class="block_3">Phân tách số liệu thống kê từ dữ liệu chuỗi</li>
	<li class="block_3">Tạo dữ liệu sử dụng Hidden Markov Models</li>
	<li class="block_3">Xác định trình tự bảng chữ cái cùng với Conditional Random Fields</li>
	<li class="block_4">Phân tích thị trường chứng khoán</li>
</ul>
	<p class="block_5">Hiểu về dữ liệu tuần tự (Squential data)<span class="calibre2">  </span></p>
	<p class="block_1">Trong thế giới của ML (máy học &ndash; Machine Learning), chúng ta gặp rất nhiều dạng dữ liệu khác nhau như hình ảnh,văn bản, video, … Những dạng dữ liệu này cần những dạng lập mô hình khác nhau. Dữ liệu tuần tự ( sequential data) <span class="calibre2">là dữ liệu  trong đó việc quan trọng nhất là được xắp xếp một cách tuần tự (sequential). Dữ liệu chuỗi (time-series data) là một biểu hiện cụ thể của dữ liệu tuần tự.</span></p>
	<p class="block_1">Về cơ bản những giá trị được đánh dấu thời gian(time-stamped) được lấy từ những dữ liệu nguồn như: cảm biến, mic, biến động thị trường,… Những dữ liệu chuỗi (time-series) có rất nhiều nét đặc trưng quan trong cần được mô hình hóa theo thứ tự để phân tích dữ liệu hiệu quả hơn.</p>
	<p class="block_1">Các phép đo chúng ta thường gặp trong dữ liệu chuỗi là: thực hiện trong khoảng thời gian cố định và tương ứng với các thông số được xác định trước. Những phép đo này được xắp xếp trên một khoảng thời gian để lưu trữ, và thứ tự của chúng xuất hiện là rất quan trong. Chúng ta sử dụng những thứ tự này để phân tách chúng từ dữ liệu.</p>
	<p class="block_1">Trong chương này chúng ta sẽ học cách xây dựng mô hình mô tả dữ liệu chuỗi hoặc trình tự của chúng nói chung. Những mô hình này sử dụng để hiểu các trạng thái của một biến qua thời gian. Sau đó chúng ta sẽ dùng những mô hình này để dự đoán tương lai dựa trên những những trạng thái cũ.</p>
	<p class="block_1">Phân tích chuỗi dữ liệu được dùng một cách chuyên sâu trong phan tích kinh tế, phân tích dữ liệu cảm biến, nhận diện giọng nói, kinh tế, thời tiết, chế tạo,… Chúng ta sẽ khám phá nhiều tình huống khá nhau khi chúng ta phải đối mặt với việc phân tích dữ liệu chuỗi và xem cách nào để chúng ta xây dựng một bộ giải pháp. Chúng ta sẽ sử dụng một bộ thư viện gọi là <i class="calibre3">Pandas</i> để quản lý tất cả những hoạt động liên quan đến dữ liệu chuỗi. Chúng ta cũng sẽ sử dụng thêm 3 thư viện là <i class="calibre3">hmmlearn</i> và <i class="calibre3">pystruct</i>, <i class="calibre3">cvxopt</i> trong chương này. </p>
	<div class="frame_"><p class="block_6">$pip3 install pandas</p><p class="block_7">$pip3 install hmmlearn</p><p class="block_7">$pip3 install pystruct</p><p class="block_8">$pip3 install cvxopt</p></div>
	<p class="block_9">&nbsp;</p>
	<p class="block_5">Xử lý dữ liệu chuỗi với Pandas</p>
	<p class="block_1">Hãy bắt đầu bằng cách xử lý dữ liệu chuỗi bằng Pandas. Trong phần này chúng ta sẽ chuyển dổi một chuỗi số vào trong chuỗi thời gian và biểu diễn nó thành đồ thị. Pandas cho ta một lựa chọn để thêm đánh dấu thời gian,tổ chức dữ liệu, và vận hành hiệu quả trên nó:</p>
	<p class="block_10"><span class="text_">import </span><span class="text_1">numpy </span><span class="text_">as </span><span class="text_1">np<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">matplotlib.pyplot </span><span class="text_">as </span><span class="text_1">plt<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">pandas </span><span class="text_">as </span><span class="text_1">pd<br class="calibre4" /></span><span class="text_2"># Tạo hàm để đọc dữ liệu nhập. Tham số index là số cột bên trong dữ liệu<br class="calibre4" /></span><span class="text_">def </span><span class="text_3">read_data</span><span class="text_1">(input_file</span><span class="text_">,</span><span class="text_1">index):<br class="calibre4" /><span class="calibre5">    input_data=np.loadtxt(input_file</span></span><span class="text_">,</span><span class="text_4">delimiter</span><span class="text_1">=</span><span class="text_5">','</span><span class="text_1">)<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2">#Tạo một hàm lambda để chuyển đổi từ string thành format ngày tháng trong Pandas:<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">to_date=</span><span class="text_">lambda </span><span class="text_1">x</span><span class="text_">,</span><span class="text_1">y:</span><span class="text_6">str</span><span class="text_1">(</span><span class="text_6">int</span><span class="text_1">(x))+</span><span class="text_5">'-'</span><span class="text_1">+</span><span class="text_6">str</span><span class="text_1">(</span><span class="text_6">int</span><span class="text_1">(y))<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Sử dụng lambda để lấy ngày bắt đầu từ dòng đầu tiên trong file input<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">start=to_date(input_data[</span><span class="text_7">0</span><span class="text_">,</span><span class="text_7">0</span><span class="text_1">]</span><span class="text_">,</span><span class="text_1">input_data[</span><span class="text_7">0</span><span class="text_">,</span><span class="text_7">1</span><span class="text_1">])<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Thư viện Pandas cần ngày kết thúc để chọn lọc khi chúng ta thực hiện các phép tính, vì thế chúng ta cần tăng ngày cuối ở dòng cuối cùng bằng một tháng:<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">if </span><span class="text_1">input_data[-</span><span class="text_7">1</span><span class="text_">,</span><span class="text_7">1</span><span class="text_1">]==</span><span class="text_7">12</span><span class="text_1">:<br class="calibre4" /><span class="calibre5">        year=input_data[-</span></span><span class="text_7">1</span><span class="text_">,</span><span class="text_7">0</span><span class="text_1">]+</span><span class="text_7">1<br class="calibre4" /><span class="calibre5">        </span></span><span class="text_1">month=</span><span class="text_7">1<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">else</span><span class="text_1">:<br class="calibre4" /><span class="calibre5">        year=input_data[-</span></span><span class="text_7">1</span><span class="text_">,</span><span class="text_7">0</span><span class="text_1">]<br class="calibre4" /><span class="calibre5">        month=input_data[-</span></span><span class="text_7">1</span><span class="text_">,</span><span class="text_7">1</span><span class="text_1">]+</span><span class="text_7">1<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">end=to_date(year</span><span class="text_">,</span><span class="text_1">month)<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2">#Tạo một list các vị trí cùng với ngày tháng dùng ngày bắt đầu và kết thúc và lặp lại trong một tháng:<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">date_indices=pd.date_range(start</span><span class="text_">,</span><span class="text_1">end</span><span class="text_">,</span><span class="text_4">freq</span><span class="text_1">=</span><span class="text_5">'M'</span><span class="text_1">)<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2">#Tạo chuỗi dữ liệu liên tục dùng timestamps<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">output=pd.Series(input_data[:</span><span class="text_">,</span><span class="text_1">index]</span><span class="text_">,</span><span class="text_4">index</span><span class="text_1">=date_indices)<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">return </span><span class="text_1">output<br class="calibre4" /></span><span class="text_2">#Tạo ham main để bắt đầu<br class="calibre4" /></span><span class="text_">if </span><span class="text_1">__name__==</span><span class="text_5">"__main__"</span><span class="text_1">:<br class="calibre4" /><span class="calibre5">    input_file=</span></span><span class="text_5">'data/chap11/data_2D.txt'<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Chỉ định số cột có trong dữ liệu<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">indices=[</span><span class="text_7">2</span><span class="text_">,</span><span class="text_7">3</span><span class="text_1">]<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2">#Tạo vòng lặp tất cả các cột và đọc dữ liệu ở mỗi cột<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">for </span><span class="text_1">index </span><span class="text_">in </span><span class="text_1">indices:<br class="calibre4" /><span class="calibre5">        timeseries=read_data(input_file</span></span><span class="text_">,</span><span class="text_1">index)<br class="calibre4" /><span class="calibre5">        </span></span><span class="text_2">#Biểu diễn dữ liệu<br class="calibre4" /><span class="calibre5">        </span></span><span class="text_1">plt.figure()<br class="calibre4" /><span class="calibre5">        timeseries.plot()</span></span><span class="text_1"><br class="calibre4" /><span class="calibre5">        plt.title(</span></span><span class="text_5">"Chiều "</span><span class="text_1">+</span><span class="text_6">str</span><span class="text_1">(index-</span><span class="text_7">1</span><span class="text_1">))<br class="calibre4" /><span class="calibre5">    plt.show()</span></span></p>
	<p class="block_9">&nbsp;</p>
	<p class="block_1">Kết quả in ra sẽ gồm 2 bảng ( vì chúng ta sử dụng 2 cột)</p>
	<p class="block_1"><img alt="Image" src="images/000003.png" class="calibre6" /><img alt="Image" src="images/000001.png" class="calibre6" /></p>
	<p class="block_1">Bảng thứ 1 là chiều dữ liệu 1 và bảng thứ 2 là chiều dữ liệu thứ 2</p>
	<p class="block_5">Chia chuỗi dữ liệu</p>
	<p class="block_1">Bây giờ chúng ta đã biết cách xử lý chuỗi dữ liệu, giờ thì phải tách nó ra. Quá trình tách này là quá trình chia dữ liệu khác nhau thành các phần nhỏ khác nhau và phân tích các thông tin liên quan đến nhau. Nó rất hữu dụng khi chúng ta làm việc với bộ dữ liệu chuỗi. Thay vì sử dụng trích xuất mục lục (indeces) chúng ta sẽ dùng timestamp để chia dữ liệu của chúng ta.</p>
	<p class="block_10"><span class="text_">import </span><span class="text_8">matplotlib.pyplot </span><span class="text_">as </span><span class="text_8">plt<br class="calibre4" /></span><span class="text_1"># Sử dụng code của bài trước<br class="calibre4" /></span><span class="text_">from </span><span class="text_8">timeseries_pandas </span><span class="text_">import </span><span class="text_8">read_data<br class="calibre4" /><br class="calibre4" /></span><span class="text_1"># Load dữ liệu ở cột thứ 3 trong bộ tài liệu 2d<br class="calibre4" /></span><span class="text_8">index=</span><span class="text_7">2<br class="calibre4" /></span><span class="text_8">data=read_data(</span><span class="text_5">'data/chap11/data_2D.txt'</span><span class="text_">,</span><span class="text_8">index)<br class="calibre4" /></span><span class="text_1"># Tạo năm bắt đầu và kết thúc, sau đó vẽ dữ liệu trong vùng này<br class="calibre4" /></span><span class="text_8">start=</span><span class="text_5">'2003'<br class="calibre4" /></span><span class="text_8">end=</span><span class="text_5">'2011'<br class="calibre4" /></span><span class="text_8">plt.figure()<br class="calibre4" />data[start:end].plot()<br class="calibre4" />plt.title(</span><span class="text_5">"Dữ liệu từ năm "</span><span class="text_8">+start+</span><span class="text_5">" tới năm "</span><span class="text_8">+end)<br class="calibre4" /></span><span class="text_1"># Tạo tháng bắt đầu và tháng kết thúc, vẽ dự liệu trong vùng tháng:<br class="calibre4" /></span><span class="text_8">start=</span><span class="text_5">'1988-2'<br class="calibre4" /></span><span class="text_8">end=</span><span class="text_5">'2006-7'<br class="calibre4" /></span><span class="text_8">plt.figure()<br class="calibre4" />data[start:end].plot()<br class="calibre4" />plt.title(</span><span class="text_5">"Dữ liệu từ tháng "</span><span class="text_8">+start[-</span><span class="text_7">1</span><span class="text_8">]+</span><span class="text_5">" năm "</span><span class="text_8">+start[:-</span><span class="text_7">2</span><span class="text_8">]+</span><span class="text_5">" tới tháng "</span><span class="text_8">+end[-</span><span class="text_7">1</span><span class="text_8">]+</span><span class="text_5">" năm "</span><span class="text_8">+end[:-</span><span class="text_7">2</span><span class="text_8">])<br class="calibre4" />plt.show()</span></p>
	<p class="block_9">&nbsp;</p>
	<p class="block_1">Kết quả</p>
	<p class="block_1"><img alt="Image" src="images/000004.png" class="calibre6" /><img alt="Image" src="images/000007.png" class="calibre6" /></p>
	<p class="block_9">&nbsp;</p>
	<p class="block_5">Tính toán trên dữ liệu chuỗi</p>
	<p class="block_1">Pandas cho phép chúng ta thực hiên các phép toán trên dữ liệu chuỗi và thực hành các phép tính khác như lọc (filtering) và cộng (addition). Bạn có thể đặt vài điều kiện Panda sẽ lọc dữ liệu và trả lại tập con chính xác. Bạn có thể cộng (add) 2 chuỗi biến. Đây là cách mà chúng ta sẽ xây dựng những ứng dụng nhanh hơn mà không phải lặp lại quá trình thực hiện.</p>
	<div class="frame_"><p class="block_11"><span class="text_">import </span><span class="text_1">matplotlib.pyplot </span><span class="text_">as </span><span class="text_1">plt<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">pandas </span><span class="text_">as </span><span class="text_1">pd<br class="calibre4" /></span><span class="text_2"># Sử dụng code bài trước<br class="calibre4" /></span><span class="text_">from </span><span class="text_1">timeseries_pandas </span><span class="text_">import </span><span class="text_1">read_data<br class="calibre4" />input_file=</span><span class="text_5">"data/chap11/data_2D.txt"<br class="calibre4" /></span><span class="text_2"># Load cột 3 và 4 thành 2 biến khác nhau<br class="calibre4" /></span><span class="text_1">x1=read_data(input_file</span><span class="text_">,</span><span class="text_7">2</span><span class="text_1">)<br class="calibre4" />x2=read_data(input_file</span><span class="text_">,</span><span class="text_7">3</span><span class="text_1">)<br class="calibre4" /></span><span class="text_2"># Tạo 2 khung dữ liệu bằng cách đặt tên cho 2 chiều<br class="calibre4" /></span><span class="text_1">data=pd.DataFrame({</span><span class="text_5">'dim1'</span><span class="text_1">:x1</span><span class="text_">,</span><span class="text_5">'dim2'</span><span class="text_1">:x2})<br class="calibre4" /></span><span class="text_2"># Vẽ dữ liệu bằng cách chỉ định năm bắt đầu và kết thúc:<br class="calibre4" /></span><span class="text_1">start=</span><span class="text_5">'1968'<br class="calibre4" /></span><span class="text_1">end=</span><span class="text_5">'1975'<br class="calibre4" /></span><span class="text_1">data[start:end].plot()<br class="calibre4" />plt.title(</span><span class="text_5">'Dữ liệu ban đầu'</span><span class="text_1">)<br class="calibre4" /></span><span class="text_2"># Lọc dữ liệu sử dụng điều kiện và vẽ nó ra. Trong trường hợp này chúng ta sẽ lấy dữ liệu ở tất cả các điểm dữ liệu dim1 và nó phải nhỏ hơn 45 và giá trị tại dim2 phải lớn hơn 30:<br class="calibre4" /></span><span class="text_1">mdata=data[(data[</span><span class="text_5">'dim1'</span><span class="text_1">]&lt;</span><span class="text_7">45</span><span class="text_1">)&amp;(data[</span><span class="text_5">'dim2'</span><span class="text_1">]&gt;</span><span class="text_7">30</span><span class="text_1">)]<br class="calibre4" />mdata[start:end].plot()<br class="calibre4" />plt.title(</span><span class="text_5">"dim1&lt;45 &amp; dim2 &gt; 30"</span><span class="text_1">)<br class="calibre4" /></span><span class="text_2"># Chúng ta cũng có thể + 2 series trong Pandas. Hãy thử dim1+dim2 bằng ngày bắt đầu và kết thúc:<br class="calibre4" /></span><span class="text_1">plt.figure()<br class="calibre4" />diff=data[start:end][</span><span class="text_5">'dim1'</span><span class="text_1">]+data[start:end][</span><span class="text_5">'dim2'</span><span class="text_1">]<br class="calibre4" />diff.plot()<br class="calibre4" />plt.title(</span><span class="text_5">"Tổng của dim1 và dim2"</span><span class="text_1">)<br class="calibre4" />plt.show()</span></p><p class="block_12"></p></div>
	<p class="block_1"><img alt="Image" src="images/000010.png" class="calibre7" /></p>
	<p class="block_1"><img alt="Image" src="images/000009.png" class="calibre6" /><img alt="Image" src="images/000002.png" class="calibre6" /></p>
	<p class="block_9">&nbsp;</p>
	<p class="block_5">Trích xuất số liệu thống kê từ dữ liệu chuỗi</p>
	<p class="block_1">Để trích xuất những phần có ý nghĩa từ chuỗi dữ liệu, chúng ta phải trích xuất các thống kê từ nó. Những số liệu thống kê này có thể là những thứ như các số trung bình (mean), phương sai (variance), số tương quan (correlation), giá trị max … Những số liệu thống kê phải được tính toán trên một cuộn cơ bản sử dụng một window. Chúng ta sử dụng một window được xác định trước về cỡ và giữ những tính toán những thống kê bên trong đó. Khi chúng ta biểu diễn những thống kê theo thời gian, chúng ta sẽ nhìn thấy những phần thông tin riêng biệt. Giờ thì hãy xem các pandas tách những thống kê từ dữ liệu chuỗi theo thời gian:</p>
	<div class="frame_"><p class="block_11"><span class="text_">import </span><span class="text_1">numpy </span><span class="text_">as </span><span class="text_1">np<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">matplotlib.pyplot </span><span class="text_">as </span><span class="text_1">plt<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">pandas </span><span class="text_">as </span><span class="text_1">pd<br class="calibre4" /><br class="calibre4" /></span><span class="text_">from </span><span class="text_1">timeseries_pandas </span><span class="text_">import </span><span class="text_1">read_data<br class="calibre4" /><br class="calibre4" /></span><span class="text_2"># Load cột 3 và cột 4 từ dữ liệu thành 2 biến<br class="calibre4" /></span><span class="text_1">x1=read_data(</span><span class="text_5">'../data/chap11/data_2D.txt'</span><span class="text_">,</span><span class="text_7">2</span><span class="text_1">)<br class="calibre4" />x2=read_data(</span><span class="text_5">"../data/chap11/data_2D.txt"</span><span class="text_">,</span><span class="text_7">3</span><span class="text_1">)<br class="calibre4" /></span><span class="text_2">#Tạo dataframe và đặt tên để tạo dữ liệu 2 chiều dim1,dim2<br class="calibre4" /></span><span class="text_1">data=pd.DataFrame({</span><span class="text_5">'dim1'</span><span class="text_1">:x1</span><span class="text_">,</span><span class="text_5">'dim2'</span><span class="text_1">:x2})<br class="calibre4" /></span><span class="text_2"># Tách lấy giá trị lớn nhất và nhỏ nhất ở mỗi chiều<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">"Giá trị lớn nhất ở mỗi chiều"</span><span class="text_1">)<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(data.max())<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">"Giá trị nhỏ nhất ở mỗi chiều"</span><span class="text_1">)<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(data.min())<br class="calibre4" /></span><span class="text_2"># Tách lấy giá trị trung bình của từng chiều và giá trị trung bình ở 12 hàng đầu tiên<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">"Giá trị trung bình của từng chiều"</span><span class="text_1">)<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(data.mean())<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">"Giá trị trung bình giữa 2 chiều theo thời gian"</span><span class="text_1">)<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(data.mean(</span><span class="text_7">1</span><span class="text_1">)[:</span><span class="text_7">12</span><span class="text_1">])<br class="calibre4" /></span><span class="text_2"># Vẽ biểu đồ sử dụng cỡ window là 24:<br class="calibre4" /></span><span class="text_1">start=</span><span class="text_5">'1988-2'<br class="calibre4" /></span><span class="text_1">end=</span><span class="text_5">'2006-7'<br class="calibre4" /></span><span class="text_1">data[start:end].rolling(</span><span class="text_4">center</span><span class="text_1">=</span><span class="text_">False,</span><span class="text_4">window</span><span class="text_1">=</span><span class="text_7">24</span><span class="text_1">).mean().plot()<br class="calibre4" />plt.title(</span><span class="text_5">"Giá trị trung bình"</span><span class="text_1">)<br class="calibre4" /></span><span class="text_2">#plt.show()<br class="calibre4" /># Các hệ số tương quan<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">"Hệ số tương quan</span><span class="text_">\n</span><span class="text_5">"</span><span class="text_">,</span><span class="text_1">data.corr())<br class="calibre4" /></span><span class="text_2"># Vẽ biểu đồ sử dụng window size = 60<br class="calibre4" /></span><span class="text_1">plt.figure()<br class="calibre4" />plt.title(</span><span class="text_5">'Hệ số tương quan'</span><span class="text_1">)<br class="calibre4" />data[start:end][</span><span class="text_5">'dim1'</span><span class="text_1">].rolling(</span><span class="text_4">window</span><span class="text_1">=</span><span class="text_7">60</span><span class="text_1">).corr(</span><span class="text_4">other</span><span class="text_1">=data[start:end][</span><span class="text_5">'dim2'</span><span class="text_1">]).plot()<br class="calibre4" />plt.show()</span></p><p class="block_12"></p></div>
	<p class="block_9">&nbsp;</p>
	<p class="block_1"><img alt="Image" src="images/000000.png" class="calibre6" /><img alt="Image" src="images/000006.png" class="calibre6" /></p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_13">Giá trị lớn nhất ở mỗi chiều</p>
	<p class="block_14"><span class="calibre5">dim1    99.98</span></p>
	<p class="block_14"><span class="calibre5">dim2    99.97</span></p>
	<p class="block_14">dtype: float64</p>
	<p class="block_14">Giá trị nhỏ nhất ở mỗi chiều</p>
	<p class="block_14"><span class="calibre5">dim1    0.18</span></p>
	<p class="block_14"><span class="calibre5">dim2    0.16</span></p>
	<p class="block_14">dtype: float64</p>
	<p class="block_14">Giá trị trung bình của từng chiều</p>
	<p class="block_14"><span class="calibre5">dim1    49.030541</span></p>
	<p class="block_14"><span class="calibre5">dim2    50.983291</span></p>
	<p class="block_14">dtype: float64</p>
	<p class="block_14">Giá trị trung bình giữa 2 chiều theo thời gian</p>
	<p class="block_14"><span class="calibre5">1900-01-31    85.595</span></p>
	<p class="block_14"><span class="calibre5">1900-02-28    75.310</span></p>
	<p class="block_14"><span class="calibre5">1900-03-31    27.700</span></p>
	<p class="block_14"><span class="calibre5">1900-04-30    44.675</span></p>
	<p class="block_14"><span class="calibre5">1900-05-31    31.295</span></p>
	<p class="block_14"><span class="calibre5">1900-06-30    44.160</span></p>
	<p class="block_14"><span class="calibre5">1900-07-31    67.415</span></p>
	<p class="block_14"><span class="calibre5">1900-08-31    56.160</span></p>
	<p class="block_14"><span class="calibre5">1900-09-30    51.495</span></p>
	<p class="block_14"><span class="calibre5">1900-10-31    61.260</span></p>
	<p class="block_14"><span class="calibre5">1900-11-30    30.925</span></p>
	<p class="block_14"><span class="calibre5">1900-12-31    30.785</span></p>
	<p class="block_14">Freq: M, dtype: float64</p>
	<p class="block_14">Hệ số tương quan</p>
	<p class="block_14"><span class="calibre5">          dim1     dim2</span></p>
	<p class="block_14"><span class="calibre5">dim1  1.00000  0.00627</span></p>
	<p class="block_15"><span class="calibre5">dim2  0.00627  1.00000</span></p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_5">Tạo dữ liệu sử dụng mô hình Hidden Markov.</p>
	<p class="block_1"><span class="calibre2">Mô hình Hidden Markov(HMM) là một kỹ thuật phân tích mạnh mẽ trong việc phân tích dữ liệu liên tục nối tiếp (chuỗi dữ liệu). Nó giả định rằng hệ thống đã được mô hình là một quá trình xử lý Markov cùng với những trạng thái ẩn. Nó có nghĩa là những hệ thống cơ bản có thể là một trong số những trạng thái đó. Nó duyệt qua tất cả các trạng thái  kế tiếp nhau và tạo ra những chuỗi output. Chúng ta có thể chỉ cần quan sát kết quả đầu ra chứ không cần quan tâm đến các trạng thái của chuỗi. Vì thế những trạng thái đó là ẩn (Hidden) đối với chúng ta. Mục đích của chúng ta là mô hình dữ liệu để chúng ta có thể suy luận ra sự biến đổi trạng thái của những dữ liệu không biết.</span></p>
	<p class="block_1">Để hiểu về HMM hãy xem ví dụ một người bán hàng có thể di chuyển ở 3 thành phố để làm công việc của anh ấy: London, Barcelona, New York. NHiệm vụ của anh ấy cần làm là di chuyển trong thời gian ngắn nhất để có hiệu quả nhất trong công việc. Xem xét công việc của anh ấy và lịch trình làm việc, chúng ta có một bộ xác xuất quyết định để đi từ thành phố X-&gt; thành phố Y. Như thông tin được đưa ra ở bên dưới, P(X,Y) là thời gian tạm tính để đi từ X-&gt;Y.</p>
	<p class="block_13">P(London -&gt; London) = 0.10</p>
	<p class="block_14">P(London -&gt; Barcelona) = 0.70</p>
	<p class="block_14">P(London -&gt; NY) = 0.20</p>
	<p class="block_14">P(Barcelona -&gt; Barcelona) = 0.15</p>
	<p class="block_14">P(Barcelona -&gt; London) = 0.75</p>
	<p class="block_14">P(Barcelona -&gt; NY) = 0.10</p>
	<p class="block_14">P(NY -&gt; NY) = 0.05</p>
	<p class="block_15">P(NY -&gt; London) = 0.60</p>
	<p class="block_1">P(NY -&gt; Barcelona) = 0.35</p>
	<p class="block_1">Hãy thử biểu diễn những thông tin này bằng ma trận chuyển tiếp:</p>
	<p class="block_13">London Barcelona NY</p>
	<p class="block_14">London 0.10 0.70 0.20</p>
	<p class="block_14">Barcelona 0.75 0.15 0.10</p>
	<p class="block_15">NY 0.60 0.35 0.05</p>
	<p class="block_1">GIờ chúng ta có tất cả các thông tin, giờ thì tiếp tục tạo báo cáo vấn đề. Người bán hàng này bắt đầu chuyến đi vào thử Ba từ London và anh ấy có một kế hoạch riêng vào thứ Sáu. Nhưng nó sẽ dựa trên ván đề là anh ấy ở đâu. Xác xuất anh ấy sẽ ở Barcelona vào thứ Sáu là bao nhiêu ? Bảng sau sẽ giúp chúng ta đoán đc điều đó.</p>
	<p class="block_1">Nếu chúng ta không có Chuooixx Markov (Markov Chain) để mô hình vấn đề này thì chúng ta sẽ không biết lịch trình di chuyển của anh ấy thế nào. Nhiệm vụ của chúng ta là có thể nói anh ấy có khả năng ở thành phố nào trong một thời gian nhất định. Nếu chúng ta biểu thị ma trận chuyển tiếp bằng thời gian T và ngày hiện tại bởi hàm X(i) thì ta có</p>
	<p class="block_1">X(i+1)= X(i).T</p>
	<p class="block_1">Trong trường hợp chúng ta đặt ra, ngày thứ Sáu là ngày sau ngày bắt đầu (thứ Ba) 3 này. Nó có nghĩa là chúng ta phải tính X(i+3).</p>
	<p class="block_1">Phép tính nhìn giống như sau: </p>
	<ul class="list_">
	<li class="block_2">X(i+1)=X(i).T</li>
	<li class="block_3">X(i+2)=X(i+1).T</li>
	<li class="block_3">X(i+3)=X(i+2).T =&gt; về bản chất nó là X(i+3)=X(i)T^3</li>
	<li class="block_4">chúng ta cầ đặt X(i) được cho ở đây X(i)=[0.10 0.70 0.20]</li>
</ul>
	<p class="block_1">Bước tiếp theo là chúng ta tính khối lập phương ma trận T^3. Có rất nhiều tools để có thể tính online cái này vd : <a class="text_9" href="http://matrix.reshish.com/multiplication.php">http://matrix.reshish.com/multiplication.php</a>. Sauk hi bạn đã tính toán xong bạn sẽ nhìn thấy kết quả là thứ Năm:</p>
	<p class="block_1">P(London)=0.31</p>
	<p class="block_1">P(Barcelona)=0.53</p>
	<p class="block_1">P(NY)=0.16</p>
	<p class="block_1">Như bạn có thể thấy bên trên cơ hội anh ấy có mặt ở Barce là cao nhất (0.53). Điều này cũng có nghĩa về mặt địa lý thì Barce gần London hơn NY.</p>
	<p class="block_1">đến phần dùng code</p>
	<div class="frame_"><p class="block_11"><span class="text_">import </span><span class="text_1">datetime<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">numpy </span><span class="text_">as </span><span class="text_1">np<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">matplotlib.pyplot </span><span class="text_">as </span><span class="text_1">plt<br class="calibre4" /></span><span class="text_">from </span><span class="text_1">hmmlearn.hmm </span><span class="text_">import </span><span class="text_1">GaussianHMM<br class="calibre4" /><br class="calibre4" /><br class="calibre4" /></span><span class="text_2">#Load Data từ file txt<br class="calibre4" /></span><span class="text_1">data=np.loadtxt(</span><span class="text_5">'../data/chap11/data_1D.txt'</span><span class="text_">,</span><span class="text_4">delimiter</span><span class="text_1">=</span><span class="text_5">','</span><span class="text_1">)<br class="calibre4" /></span><span class="text_2"># Lấy dữ liệu cột thứ 3 để training<br class="calibre4" /></span><span class="text_1">X=np.column_stack([data[:</span><span class="text_">,</span><span class="text_7">2</span><span class="text_1">]])<br class="calibre4" /></span><span class="text_2"># Tạo mô hình phân loại HMM với số components=5 và sử dụng hiệp phương sai theo đường chéo<br class="calibre4" /></span><span class="text_1">hmm=GaussianHMM(</span><span class="text_4">n_components</span><span class="text_1">=</span><span class="text_7">5</span><span class="text_">,</span><span class="text_4">covariance_type</span><span class="text_1">=</span><span class="text_5">'diag'</span><span class="text_">,</span><span class="text_4">n_iter</span><span class="text_1">=</span><span class="text_7">1000</span><span class="text_1">)<br class="calibre4" /></span><span class="text_2">#Train HMM<br class="calibre4" /></span><span class="text_1">hmm.fit(X)<br class="calibre4" /></span><span class="text_2"># In khoảng cách mean và phương sai (variance) cho mỗi component của mô hình HMM:<br class="calibre4" /></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">'Means and Variances:'</span><span class="text_1">)<br class="calibre4" /></span><span class="text_">for </span><span class="text_1">i </span><span class="text_">in </span><span class="text_6">range</span><span class="text_1">(hmm.n_components):<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">'</span><span class="text_">\n</span><span class="text_5">Hidden State'</span><span class="text_">,</span><span class="text_1">i+</span><span class="text_7">1</span><span class="text_1">)<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">'Mean='</span><span class="text_">,</span><span class="text_6">round</span><span class="text_1">(hmm.means_[i][</span><span class="text_7">0</span><span class="text_1">]</span><span class="text_">,</span><span class="text_7">2</span><span class="text_1">))<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">'Variance='</span><span class="text_">,</span><span class="text_6">round</span><span class="text_1">(np.diag(hmm.covars_[i])[</span><span class="text_7">0</span><span class="text_1">]</span><span class="text_">,</span><span class="text_7">2</span><span class="text_1">))<br class="calibre4" /></span><span class="text_2">#Tạo bộ samples 1200 điểm dữ liệu sử dụng mô hình HMM đã tạo và vẽ nó lên đồ thị<br class="calibre4" /></span><span class="text_1">num_samples=</span><span class="text_7">1200<br class="calibre4" /></span><span class="text_1">generated_data</span><span class="text_">, </span><span class="text_1">_=hmm.sample(num_samples)<br class="calibre4" />plt.plot(np.arange(num_samples)</span><span class="text_">,</span><span class="text_1">generated_data[:</span><span class="text_">,</span><span class="text_7">0</span><span class="text_1">]</span><span class="text_">,</span><span class="text_4">c</span><span class="text_1">=</span><span class="text_5">'black'</span><span class="text_1">)<br class="calibre4" />plt.title(</span><span class="text_5">'Dữ liệu đã tạo'</span><span class="text_1">)<br class="calibre4" />plt.show()</span></p><p class="block_12"></p></div>
	<p class="block_9">&nbsp;</p>
	<p class="block_1">Kết quả thu được:</p>
	<p class="block_16"><img alt="Image" src="images/000008.png" class="calibre8" /></p>
	<p class="block_1">Terminal:</p>
	<p class="block_13">Means and Variances:</p>
	<p class="block_17">&nbsp;</p>
	<p class="block_14">Hidden State 1</p>
	<p class="block_14">Mean= 8.6</p>
	<p class="block_14">Variance= 0.26</p>
	<p class="block_17">&nbsp;</p>
	<p class="block_14">Hidden State 2</p>
	<p class="block_14">Mean= 2.6</p>
	<p class="block_14">Variance= 0.26</p>
	<p class="block_17">&nbsp;</p>
	<p class="block_14">Hidden State 3</p>
	<p class="block_14">Mean= 4.6</p>
	<p class="block_14">Variance= 0.25</p>
	<p class="block_17">&nbsp;</p>
	<p class="block_14">Hidden State 4</p>
	<p class="block_14">Mean= 0.6</p>
	<p class="block_14">Variance= 0.25</p>
	<p class="block_17">&nbsp;</p>
	<p class="block_14">Hidden State 5</p>
	<p class="block_14">Mean= 6.59</p>
	<p class="block_15">Variance= 0.25</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_5">Nhận diện trình tự bảng chữ cái cùng với Conditional Random Fields</p>
	<p class="block_1"><b class="calibre1">Conditional Random Fields( CRFs)</b> là mô hình xác xuất thường được sử dụng để phân tích cấu trúc dữ liệu. Chúng ta sử dụng chúng để dán nhãn và phân loại dữ liệu tuần tự ( hoặc liên tục) theo nhiều cách khác nhau. Một thứ chúng ta càn chú ý về CRFs chúng là mô hình phân biệt . Nó tương phản với mô hình Hidden Markov đã nói ở trên, ns sẽ tạo ra những mô hình.</p>
	<p class="block_1">Chúng ta có thể định nghĩa một xác xuất có điều kiện trên một chuỗi có dán nhãn. Chúng ta dùng framework này để xây dựng một mô hình CRF. trong mô hình HMM chúng ta phải tạo điểm phân phối chung trên các chuỗi và các nhãn.</p>
	<p class="block_1">Một trong những lợi thế của CRF là chúng có điều kiện. Đây không phải là trường hợp sử dụng cùng với HMM. CRFs không giả định bất cứ sự độc lập nào với kết quả đầu ra còn HMM cho rằng đầu ra tại bất kỳ thời điểm nào đều độc lập với kết quả trước đó. HMM cần giả định này để đảm bảo rằng quá trình suy luận hoạt đông theo một cách nào đó. Nhưng giả định này thì không phải lúc nào cũng đúng. trong thực tế dữ liệu được điền phụ thuộc vào thời gian.</p>
	<p class="block_1">CRFs có xu hướng tốt hơn HMMs ở trong một số ứng dụng như xử lý ngôn ngữ, đoán chữ từ âm thành, công nghệ sinh học … Trong phần này chúng ta sẽ thảo luận về vấn đế sử dụng CRFs để phân tích trình tự của bảng chữ cái.</p>
	<p class="block_13">Hiện tại không cài được lib Pystruct nên bỏ qua phần này :D</p>
	<p class="block_15">Dưới đây là code theo cuốn sách</p>
	<div class="frame_"><p class="block_11"><span class="text_">import </span><span class="text_1">os<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">argparse <br class="calibre4" /></span><span class="text_">import </span><span class="text_1">string<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">pickle <br class="calibre4" /><br class="calibre4" /></span><span class="text_">import </span><span class="text_1">numpy </span><span class="text_">as </span><span class="text_1">np<br class="calibre4" /></span><span class="text_">import </span><span class="text_1">matplotlib.pyplot </span><span class="text_">as </span><span class="text_1">plt<br class="calibre4" /></span><span class="text_">from </span><span class="text_1">pystruct.datasets </span><span class="text_">import </span><span class="text_1">load_letters<br class="calibre4" /></span><span class="text_">from </span><span class="text_1">pystruct.models </span><span class="text_">import </span><span class="text_1">ChainCRF <br class="calibre4" /></span><span class="text_">from </span><span class="text_1">pystruct.learners </span><span class="text_">import </span><span class="text_1">FrankWolfeSSVM<br class="calibre4" /><br class="calibre4" /></span><span class="text_">def </span><span class="text_3">build_arg_parser</span><span class="text_1">():<br class="calibre4" /><span class="calibre5">    parser = argparse.ArgumentParser(</span></span><span class="text_4">description</span><span class="text_1">=</span><span class="text_5">'Trains a Conditional</span><span class="text_">\<br class="calibre4" /></span><span class="text_5"><span class="calibre5">            Random Field classifier'</span></span><span class="text_1">)<br class="calibre4" /><span class="calibre5">    parser.add_argument(</span></span><span class="text_5">"--C"</span><span class="text_">, </span><span class="text_4">dest</span><span class="text_1">=</span><span class="text_5">"c_val"</span><span class="text_">, </span><span class="text_4">required</span><span class="text_1">=</span><span class="text_">False, </span><span class="text_4">type</span><span class="text_1">=</span><span class="text_6">float</span><span class="text_">,<br class="calibre4" /><span class="calibre5">            </span></span><span class="text_4">default</span><span class="text_1">=</span><span class="text_7">1.0</span><span class="text_">, </span><span class="text_4">help</span><span class="text_1">=</span><span class="text_5">'C value to be used for training'</span><span class="text_1">)<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">return </span><span class="text_1">parser<br class="calibre4" /><br class="calibre4" /></span><span class="text_2"># Class to model the CRF<br class="calibre4" /></span><span class="text_">class </span><span class="text_1">CRFModel(</span><span class="text_6">object</span><span class="text_1">):<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">def </span><span class="text_10">__init__</span><span class="text_1">(</span><span class="text_11">self</span><span class="text_">, </span><span class="text_1">c_val=</span><span class="text_7">1.0</span><span class="text_1">):<br class="calibre4" /><span class="calibre5">        </span></span><span class="text_11">self</span><span class="text_1">.clf = FrankWolfeSSVM(</span><span class="text_4">model</span><span class="text_1">=ChainCRF()</span><span class="text_">, <br class="calibre4" /><span class="calibre5">                </span></span><span class="text_4">C</span><span class="text_1">=c_val</span><span class="text_">, </span><span class="text_4">max_iter</span><span class="text_1">=</span><span class="text_7">50</span><span class="text_1">) <br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Load the training data<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">def </span><span class="text_3">load_data</span><span class="text_1">(</span><span class="text_11">self</span><span class="text_1">):<br class="calibre4" /><span class="calibre5">        alphabets = load_letters()</span></span><span class="text_1"><br class="calibre4" /><span class="calibre5">        X = np.array(alphabets[</span></span><span class="text_5">'data'</span><span class="text_1">])<br class="calibre4" /><span class="calibre5">        y = np.array(alphabets[</span></span><span class="text_5">'labels'</span><span class="text_1">])<br class="calibre4" /><span class="calibre5">        folds = alphabets[</span></span><span class="text_5">'folds'</span><span class="text_1">]<br class="calibre4" /><br class="calibre4" /><span class="calibre5">        </span></span><span class="text_">return </span><span class="text_1">X</span><span class="text_">, </span><span class="text_1">y</span><span class="text_">, </span><span class="text_1">folds<br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Train the CRF<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">def </span><span class="text_3">train</span><span class="text_1">(</span><span class="text_11">self</span><span class="text_">, </span><span class="text_1">X_train</span><span class="text_">, </span><span class="text_1">y_train):<br class="calibre4" /><span class="calibre5">        </span></span><span class="text_11">self</span><span class="text_1">.clf.fit(X_train</span><span class="text_">, </span><span class="text_1">y_train)<br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Evaluate the accuracy of the CRF<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">def </span><span class="text_3">evaluate</span><span class="text_1">(</span><span class="text_11">self</span><span class="text_">, </span><span class="text_1">X_test</span><span class="text_">, </span><span class="text_1">y_test):<br class="calibre4" /><span class="calibre5">        </span></span><span class="text_">return </span><span class="text_11">self</span><span class="text_1">.clf.score(X_test</span><span class="text_">, </span><span class="text_1">y_test)<br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Run the CRF on unknown data<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">def </span><span class="text_3">classify</span><span class="text_1">(</span><span class="text_11">self</span><span class="text_">, </span><span class="text_1">input_data):<br class="calibre4" /><span class="calibre5">        </span></span><span class="text_">return </span><span class="text_11">self</span><span class="text_1">.clf.predict(input_data)[</span><span class="text_7">0</span><span class="text_1">]<br class="calibre4" /><br class="calibre4" /></span><span class="text_2"># Convert indices to alphabets<br class="calibre4" /></span><span class="text_">def </span><span class="text_3">convert_to_letters</span><span class="text_1">(indices):<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Create a numpy array of all alphabets<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">alphabets = np.array(</span><span class="text_6">list</span><span class="text_1">(string.ascii_lowercase))<br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Extract the letters based on input indices<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">output = np.take(alphabets</span><span class="text_">, </span><span class="text_1">indices)<br class="calibre4" /><span class="calibre5">    output = </span></span><span class="text_5">''</span><span class="text_1">.join(output)<br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">return </span><span class="text_1">output<br class="calibre4" /><br class="calibre4" /></span><span class="text_">if </span><span class="text_1">__name__==</span><span class="text_5">'__main__'</span><span class="text_1">:<br class="calibre4" /><span class="calibre5">    args = build_arg_parser().parse_args()</span></span><span class="text_1"><br class="calibre4" /><span class="calibre5">    c_val = args.c_val</span></span><span class="text_1"><br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Create the CRF model<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">crf = CRFModel(c_val)<br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Load the train and test data<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">X</span><span class="text_">, </span><span class="text_1">y</span><span class="text_">, </span><span class="text_1">folds = crf.load_data()<br class="calibre4" /><span class="calibre5">    X_train</span></span><span class="text_">, </span><span class="text_1">X_test = X[folds == </span><span class="text_7">1</span><span class="text_1">]</span><span class="text_">, </span><span class="text_1">X[folds != </span><span class="text_7">1</span><span class="text_1">]<br class="calibre4" /><span class="calibre5">    y_train</span></span><span class="text_">, </span><span class="text_1">y_test = y[folds == </span><span class="text_7">1</span><span class="text_1">]</span><span class="text_">, </span><span class="text_1">y[folds != </span><span class="text_7">1</span><span class="text_1">]<br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Train the CRF model<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">'</span><span class="text_">\n</span><span class="text_5">Training the CRF model...'</span><span class="text_1">)<br class="calibre4" /><span class="calibre5">    crf.train(X_train</span></span><span class="text_">, </span><span class="text_1">y_train)<br class="calibre4" /><br class="calibre4" /><span class="calibre5">    </span></span><span class="text_2"># Evaluate the accuracy<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_1">score = crf.evaluate(X_test</span><span class="text_">, </span><span class="text_1">y_test)<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">'</span><span class="text_">\n</span><span class="text_5">Accuracy score ='</span><span class="text_">, </span><span class="text_6">str</span><span class="text_1">(</span><span class="text_6">round</span><span class="text_1">(score*</span><span class="text_7">100</span><span class="text_">, </span><span class="text_7">2</span><span class="text_1">)) + </span><span class="text_5">'%'</span><span class="text_1">)<br class="calibre4" /><br class="calibre4" /><span class="calibre5">    indices = </span></span><span class="text_6">range</span><span class="text_1">(</span><span class="text_7">3000</span><span class="text_">, </span><span class="text_6">len</span><span class="text_1">(y_test)</span><span class="text_">, </span><span class="text_7">200</span><span class="text_1">)<br class="calibre4" /><span class="calibre5">    </span></span><span class="text_">for </span><span class="text_1">index </span><span class="text_">in </span><span class="text_1">indices:<br class="calibre4" /><span class="calibre5">        </span></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">"</span><span class="text_">\n</span><span class="text_5"><span class="calibre5">Original  ="</span></span><span class="text_">, </span><span class="text_1">convert_to_letters(y_test[index]))<br class="calibre4" /><span class="calibre5">        predicted = crf.classify([X_test[index]])</span></span><span class="text_1"><br class="calibre4" /><span class="calibre5">        </span></span><span class="text_6">print</span><span class="text_1">(</span><span class="text_5">"Predicted ="</span><span class="text_">, </span><span class="text_1">convert_to_letters(predicted))</span></p><p class="block_12"></p></div>
	<p class="block_9">&nbsp;</p>
	<p class="block_5">Phân tích thị trường chứng khoán (stock market)</p>
	<p class="block_1">Chúng ta sẽ phân tích dữ liệu thị trường chứng khoán trong phần này sử dụng mô hình Hidden Markov. Đây là một ví dụ mà trong đó dữ liệu đã được xắp xếp và đánh dấu thời gian. Chúng ta sẽ sử dụng cơ sở dữ liệu có sẵn trong thư viện matplotlib. Dữ liệu này chứa giá trị một vài cổ phiếu của một số công ty khác nhau qua nhiều năm. Mô hình Hidden Markov sẽ tạo ra những mô hình có thể phân tích dữ liệu chuỗi và phân tích những cấu trúc cơ bản. Chúng ta sẽ sử dụng mô hình này để phân tích sự biến đổi giá cổ phiểu và tạo kết quả đầu ra.</p>
	<p class="block_13">Mình không tìm hiểu về stock market nên không hiểu lắm. bỏ qua</p>
	<p class="block_14">Vì matplotlib đã deprecated nên sử dụng panda để load từ file csv<br class="calibre4" />Lấy file csv từ đây https://github.com/matplotlib/mpl_finance</p>
	<p class="block_18">&nbsp;</p>
	<p class="block_5">Tổng kết</p>
	<p class="block_1">Trong chương này chúng ta đã học cách để xây dựng mô hình học tập theo trình tự. Học về cách quản lý chuỗi dữ liệu theo thời gian bằng Pandas. Chúng ta đã thảo luận về cách chia chuỗi dự liệu theo thời gian và thực hiện các hoạt động trên đó vân vân và mây mây.</p>
	<p class="block_1">Trong chương tiếp theo chúng ta sẽ học về cách nhận dạng giọng nói và xây dựng một hệ thống tự động nhận dạng giọng nói</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>
	<p class="block_9">&nbsp;</p>

</div>

</body></html>

<footer class=" footline" >
	
</footer>


        
        </div> 
        

      </div>

    <div id="navigation">
        
        
        
        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
        
        


	 
	 
		
			<a class="nav nav-prev" href="/ai-with-python/chapter10/" title="C10: Natural Language Processing"> <i class="fa fa-chevron-left"></i></a>
		
		
			<a class="nav nav-next" href="/ai-with-python/chapter12/" title="C12: Speech Recognizer" style="margin-right: 0px;"><i class="fa fa-chevron-right"></i></a>
		
	
    </div>

    </section>
    
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="/js/clipboard.min.js?1576139178"></script>
    <script src="/js/perfect-scrollbar.min.js?1576139178"></script>
    <script src="/js/perfect-scrollbar.jquery.min.js?1576139178"></script>
    <script src="/js/jquery.sticky.js?1576139178"></script>
    <script src="/js/featherlight.min.js?1576139178"></script>
    <script src="/js/highlight.pack.js?1576139178"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="/js/modernizr.custom-3.6.0.js?1576139178"></script>
    <script src="/js/learn.js?1576139178"></script>
    <script src="/js/hugo-learn.js?1576139178"></script>

    <link href="/mermaid/mermaid.css?1576139178" rel="stylesheet" />
    <script src="/mermaid/mermaid.js?1576139178"></script>
    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
    

  </body>
</html>

