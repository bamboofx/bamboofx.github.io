<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.57.2" />
    <meta name="description" content="">


    <link rel="icon" href="/images/favicon.png" type="image/png">

    <title>C7: Tìm kiếm Heuristic :: Bamboofx&#39;s or NTVFX&#39;s Site</title>

    
    <link href="/css/nucleus.css?1576139178" rel="stylesheet">
    <link href="/css/fontawesome-all.min.css?1576139178" rel="stylesheet">
    <link href="/css/hybrid.css?1576139178" rel="stylesheet">
    <link href="/css/featherlight.min.css?1576139178" rel="stylesheet">
    <link href="/css/perfect-scrollbar.min.css?1576139178" rel="stylesheet">
    <link href="/css/auto-complete.css?1576139178" rel="stylesheet">
    <link href="/css/atom-one-dark-reasonable.css?1576139178" rel="stylesheet">
    <link href="/css/theme.css?1576139178" rel="stylesheet">
    <link href="/css/hugo-theme.css?1576139178" rel="stylesheet">
    
      <link href="/css/theme-blue.css?1576139178" rel="stylesheet">
    

    <script src="/js/jquery-3.3.1.min.js?1576139178"></script>

    <style>
      :root #header + #content > #left > #rlblock_left{
          display:none !important;
      }
      
    </style>
    
  </head>
  <body class="" data-url="/ai-with-python/chapter7/">
    <nav id="sidebar" class="">



  <div id="header-wrapper">
    <div id="header">
      <a id="logo" href="https://bamboofx.github.io/">
  <img src="https://bamboofx.github.io/images/logo.png "> </img>
</a>

    </div>
    
        <div class="searchbox">
    <label for="search-by"><i class="fas fa-search"></i></label>
    <input data-search-input id="search-by" type="search" placeholder="Search...">
    <span data-search-clear=""><i class="fas fa-times"></i></span>
</div>

<script type="text/javascript" src="/js/lunr.min.js?1576139178"></script>
<script type="text/javascript" src="/js/auto-complete.js?1576139178"></script>
<script type="text/javascript">
    
        var baseurl = "https:\/\/bamboofx.github.io\/";
    
</script>
<script type="text/javascript" src="/js/search.js?1576139178"></script>

    
  </div>

    <div class="highlightable">
    <ul class="topics">

        
          
          


 
  
    
    <li data-nav-id="/ai-with-python/" title="AI with Python (Prateek Joshi)" class="dd-item 
        parent
        
        
        ">
      <a href="/ai-with-python/">
          AI with Python (Prateek Joshi)
          
      </a>
      
      
        <ul>
          
          
          
          
        
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter1/" title="C1: Trí thông minh nhân tạo là gì?" class="dd-item ">
        <a href="/ai-with-python/chapter1/">
        C1: Trí thông minh nhân tạo là gì?
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter2/" title="C2: Classification and Regression" class="dd-item ">
        <a href="/ai-with-python/chapter2/">
        C2: Classification and Regression
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter3/" title="C3: Ensemble Learing" class="dd-item ">
        <a href="/ai-with-python/chapter3/">
        C3: Ensemble Learing
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter4/" title="C4: Detecting Patterns with Unsupervised Learning" class="dd-item ">
        <a href="/ai-with-python/chapter4/">
        C4: Detecting Patterns with Unsupervised Learning
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter5/" title="C5: Building Recommender Systems" class="dd-item ">
        <a href="/ai-with-python/chapter5/">
        C5: Building Recommender Systems
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter6/" title="C6: Logic Programing" class="dd-item ">
        <a href="/ai-with-python/chapter6/">
        C6: Logic Programing
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter7/" title="C7: Tìm kiếm Heuristic" class="dd-item active">
        <a href="/ai-with-python/chapter7/">
        C7: Tìm kiếm Heuristic
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter8/" title="C8: Thuật toán di truyền - Genetic Alogrithms" class="dd-item ">
        <a href="/ai-with-python/chapter8/">
        C8: Thuật toán di truyền - Genetic Alogrithms
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter9/" title="C9: Xây dựng game cùng với AI" class="dd-item ">
        <a href="/ai-with-python/chapter9/">
        C9: Xây dựng game cùng với AI
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter10/" title="C10: Natural Language Processing" class="dd-item ">
        <a href="/ai-with-python/chapter10/">
        C10: Natural Language Processing
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter11/" title="C11: Sequential Data" class="dd-item ">
        <a href="/ai-with-python/chapter11/">
        C11: Sequential Data
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter12/" title="C12: Speech Recognizer" class="dd-item ">
        <a href="/ai-with-python/chapter12/">
        C12: Speech Recognizer
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/ai-with-python/chapter13/" title="C13: Object Detection and Tracking" class="dd-item ">
        <a href="/ai-with-python/chapter13/">
        C13: Object Detection and Tracking
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
              
    </li>
  
 

          
          


 
  
    
    <li data-nav-id="/numpy/" title="NumPy cơ bản" class="dd-item 
        
        
        
        ">
      <a href="/numpy/">
          NumPy cơ bản
          
      </a>
      
              
    </li>
  
 

          
          


 
  
    
    <li data-nav-id="/about/" title="about" class="dd-item 
        
        
        
        ">
      <a href="/about/">
          About
          
      </a>
      
              
    </li>
  
 

          
         
    </ul>

    
    

    
    <section id="footer">
      <p>Built with <a href="https://github.com/matcornic/hugo-theme-learn"><i class="fas fa-heart"></i></a> from <a href="https://getgrav.org">Grav</a> and <a href="https://gohugo.io/">Hugo</a></p>

    </section>
  </div>
</nav>





        <section id="body">
        <div id="overlay"></div>
        <div class="padding highlightable">
              
              <div>
                <div id="top-bar">
                
                
                <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                    <span id="sidebar-toggle-span">
                        <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                          <i class="fas fa-bars"></i>
                        </a>
                    </span>
                  
                  <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
                  
                  <span class="links">
                 
                 
                    
          
          
            
            
          
          
            
            
          
          
            <a href='/'>Site</a> > <a href='/ai-with-python/'>AI with Python (Prateek Joshi)</a> > C7: Tìm kiếm Heuristic
          
         
          
         
          
        
                 
                  </span>
                </div>
                
                    <div class="progress">
    <div class="wrapper">

    </div>
</div>

                
              </div>
            </div>
            
        <div id="head-tags">
        
        </div>
        
        <div id="body-inner">
          
            <h1>
              
              C7: Tìm kiếm Heuristic
            </h1>
          

        



<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>PythonAI Chapter7</title></head><body><div class="calibre" id="calibre_link-0">
	<p class="block_">7</p>
	<p class="block_">Tìm kiếm Heuristic</p>
	<p class="block_1">Trong chương này chúng ta sẽ tìm hiểu về kỹ thuật tìm kiếm heuristic. Kỹ thuật tìm kiếm heuristic sử dụng để tìm kiếm những không gian giải pháp để đưa ra kết quả. Các tìm kiếm được tiến hành bằng cách sử dụng sử dụng phương pháp phỏng đoán(heuristic còn có nghĩa là phỏng đoán, khám phá)để hướng dẫn thuật toán tìm kiếm. Những khám phá (heuristic) này cho phép thuật toán có thể tăng tốc quá trình xử lý, nếu không có nó sẽ mất rất nhiều thời gian và giải pháp.</p>
	<p class="block_1">Học xong chương này bạn sẽ biết được những thứ cụ thể như :</p>
	<ul class="list_">
	<li class="block_2">Heuristic search là gì</li>
	<li class="block_3">Tìm kiếm biết trước và tìm kiếm không biết trước</li>
	<li class="block_3">Constraint Satisfaction Problems (CSPs- Thỏa mãn vấn đề ràng buộc)</li>
	<li class="block_3">Giải thuật tìm kím cục bộ ( local searching)</li>
	<li class="block_3">Giải thuật Simulated Annealing (Thuật toán mô phỏng luyện kim).</li>
	<li class="block_3">Xây dựng chuỗi sử dụng greedy search ( thuật tìm kiếm tham lam)</li>
	<li class="block_3">Giải quyết 1 vấn đề với các ràng buộc</li>
	<li class="block_3">Giải quyết vấn đề màu vùng</li>
	<li class="block_3">Xây dựng bộ giải mã trò chơi 8-puzzle</li>
	<li class="block_4">Xây dựng bộ giải mã trò chơi mê cung</li>
</ul>
	<p class="block_5">Heuristic search là gì ?</p>
	<p class="block_1"><span class="calibre1">Tìm kiếm và xắp xếp dữ liệu (organizing data) là một chủ đề quan trong trong AI. Có rất nhiều vấn đề cần phải tìm kiếm câu trả lời. Có rất nhiều giải pháp khả thi cho một vấn đề và chúng ta không biết cái nào là chính xác. Bằng cách tổ chức hiệu quả, chúng ta có thể tìm kiếm giải pháp một cách nhanh chóng và hiệu quả. Thông thường, có rất nhiều tùy chọn giải pháp có thể giải quyết một vấn đề nhất định mà không thuật toán nào có thể phát triển để tìm được giải pháp đúng.  Ngoài ra, qua mỗi giải pháp duy nhất là không thể vì nó rất </span>mất thời gian và nặng( còn gọi là đắt giá). Ở trường hợp thế này, chúng ta dựa trên một quy tắc giúp chúng ta có thể thu hẹp phạm vi tìm kiếm bằng cách loại bỏ những tùy chọn giải pháp mà chắc chắn là sai. Quy tắc này được gọi là <b class="calibre2">heuristic</b>. Phương pháp sử dụng heuristic (phỏng đoán, khám phá) để hướng dẫn tìm kiếm của chúng ta được gọi là <b class="calibre2">heuristic search. Heuristic </b>trong tiếng hy lạp có nghĩa là "Tìm kiếm" hoặc "khám phá" là kỹ thuật dựa trên kinh nghiệm để giải quyết vấn đề, học hỏi hay khám phá nhằm đưa ra một giải pháp mà không được đảm bảo là tối ưu &ndash; trích wiki) </p>
	<p class="block_1">Phương pháp Heuristic rất hữu dụng vì chúng giúp chúng ta rút ngắn thời gian tìm kiếm. Thậm chí nếu heuristic không thể loại bỏ hoàn toàn một số tùy chọn, thì nó cũng giúp chúng ta xắp xếp các tùy chọn để chúng ta có nhiều khả năng nhận được các giải pháp tốt hơn trước.</p>
	<p class="block_1">Trong việc xây dựng các thuật giải Heuristic người ta thường dùng các hàm Heuristic ( heuristic function) đó là các hàm đánh giá thô, giá trị của hàm phụ thuộc vào trạng thái của các bài toán tại mỗi bước xử lý. Nhờ các giá trị này ta có thể chọn được các hành động tương đối trong từng bước của thuật giải</p>
	<p class="block_5">Tìm biết trước và không biết trước</p>
	<p class="block_1">Nếu bạn đã quen thuộc trong ngành khoa học máy tính, có lẽ bạn đã nghe về một vài kỹ thuật tìm kiếm như <b class="calibre2">Depth First Search(DFS &ndash; Tìm kiếm chiều sâu),Breadth First Search(BFS &ndash; Tìm kiếm theo chiều rộng), Uniform Cost Search(UCS-Tìm kiếm đồng nhất giá).</b> Đó là những kỹ thuật tìm kiếm thường được sử dụng trên đồ thị để tìm kiếm giải phải. Vi dụ trong tìm kiếm không biết trước. Chúng không có sử dụng bất kỳ thông tin biết trước nào hoặc quy tắc nào để loại bỏ một vài hướng. Nó kiểm tra tất cả các hướng tìm kiếm và chọn một cái tối ưu.</p>
	<p class="block_1">Heuristic search, nói một cách khác thì nó có thể gọi là <b class="calibre2">Informed Search</b><i class="calibre3">( tìm khi biết trước thông tin) </i>bởi vì nó sử dụng những thông cho trước hoặc một quy tắc nào đó để loại bỏ những hướng không cần thiết. Kỹ thuật tìm kiếm không thông tin không có mục đích cần đạt đến ở kết quả. Những kỹ thuật này không thực sự biết nó đang cố gắng làm cái gì trừ khi nó gặp vấn đề gì ở mục tiêu đạt đết trong quá trình tìm kiếm.</p>
	<p class="block_1">Trong vấn đề đồ thị, Chúng ta có thể dùng thuật toán heuristic để hướng dẫn tìm kiếm. Ví dụ, tại mỗi node (nút giao, đỉnh ,..) chúng ta có thể định nghĩa một hàm heuristic và giá trị trả lại (return) là điểm số đại diện cho ước tính của hướng đi từ node hiện tại tới đích đến. Điều này sẽ cho phép thuật toán để xác định nơi nào dẫn tới đích đến.</p>
	<p class="block_1">Chúng ta cần chú ý rằng tìm kiems heuristic không phải là phương pháp tối ưu nhất. Bởi vì chúng ta không khám phá phương pháp khả năng duy nhất và chúng ta dựa vào heuristic. Nhưng nó được đảm bảo để tìm một giải pháp tốt trong một thời gian hợp lý, đó là những gì chúng ta mong đợi từ một giải pháp thực tế. Trong các tình huống thực tế, chúng ta cần những giải pháp nhanh chóng và hiệu quả. Heuristic search đưa ra cho chúng ta một giải pháp hiệu quả bằng cách đưa ra một giải pháp nhanh chóng và hợp lý. Chúng được sử dụng trong trường hợp các vấn đề không được giải quyết trong bất kỳ vấn đề nào khác hoặc mất một thời gian dài để giải quyết.</p>
	<p class="block_5">Constraint Satisfaction Problems</p>
	<p class="block_5">(CSPs - Thỏa mãn vấn đề ràng buộc)</p>
	<p class="block_1">Có rất nhiều vấn đề chúng ta phải giải quyết bởi các sự ràng buộc, Những ràng buộc này về cơ bản là những điều kiện không thể bị bác bỏ hoặc làm trái trong quá trình giải quyết vấn đề. Những vấn đề này được gọi là CSPs ( Thỏa mãn các vấn đề ràng buộc)</p>
	<p class="block_1">CPS về cơ bản là các vấn đề toán học được định nghĩa là tập hợp các biến (variables) phải thỏa mãn một số hạn chế. Khi chúng ta đi đến giải pháp cuối cùng, các trạng thái của các biến này phải thỏa mãn tất cả các điều kiện. CSPs là một dạng trong lập trình ràng buộc (<i class="calibre3">constraint programming</i>) là một mô hình trong đó mối quan hệ giữa các biến (variables) được mô tả dưới dạng ràng buộc lẫn nhau. lập trình ràng buộc cũng là một dạng của lập trình khai báo (<span class="text_">Declarative Programing)</span> . Lập trình ràng buộc còn có thể mô tả dưới dạng lập trình logic ràng buộc khi ta nhúng "ràng buộc" vào trong lập trình logic.</p>
	<p class="block_1">Những vấn đề (Problems) này đòi hỏi sử kết hợp giữa thuật toán heuristic và các kỹ thuật tìm kiếm khác giải quyết chúng trong một thời gian hợp lý. Trong trường hợp này, chúng ta sẽ sử dụng kỹ thuật <i class="calibre3">ràng buộc thỏa mãn (constraint satisfaction) </i>để giải quyết <i class="calibre3">vấn đề (problems)</i> trên <b class="calibre2">các vùng giới hạn</b>. Các vùng giới hạn này chứa những số giới hạn của các thành phần(elements). Vì chúng ta xử lý các vùng giới hạn này chúng ta có thể sử dụng các kỹ thuật tìm kiếm để đưa ra giải pháp.</p>
	<p class="block_5">Kỹ thuật tìm kiếm vùng( Local Search)</p>
	<p class="block_1">Tìm kiếm vùng (local search) là một cá thể nhỏ của CSPs. Nó cải thiện các giá trị cho tới khi các ràng buộc được thỏa mãn. Nó lặp đi lặp lại các biến cho tới khi chúng ta tới được đích cần đến. Những thuật toán thay đổi các giá giá trị trong mỗi bước xử lý để chúng ta có thể tiến gần đến đich. Trong không gian giải pháp, cập nhật các giá trị để đến gần đích tốt hơn là những giá trị đã có. Vì thế nó được gọi là local search.</p>
	<p class="block_1">Thuật toán local search cũng làm một thuật toán Heuristic search. NHững thuật toán này sử dụng một hàm để tính toán chất lượng các giá trị trong mỗi lần cập nhật. Ví dụ, nó có thể đếm các số ràng buộc (constraints) đang bị vi phạm bởi bản cập nhạt hiện tại hoặc nó có thể nhìn thấy các bản cập nhật ảnh hưởng tới khoảng cách đến đích. Cái này có thể được hiểu như là phí giành cho mỗi lần phân công. Mục đích chung của local search là tìm mức phí nhỏ nhất ở trong mỗi bước.</p>
	<p class="block_1">Giải thuật leo đồi (Hill Climbing) cũng là một dạng phổ biến của local search. Nó sử dụng một hàm heuristic để đo lường khoảng cách giữa trạng thái hiện tại và đích đế. Khi chúng ta bắt đầu, nó sẽ kiểm tra trang thái hiện tại có phải là đích đến không. Nếu đúng nó sẽ dừng lại, còn không thì nó sẽ chọn một bản cập nhật và tạo ra một trạng thái mới. Nếu trạng thái mới gần đến đích hơn là trạng thái hiện tại thì nó sẽ chọn trạng thái mới thành trạng thái hiện tại còn nếu không nó sẽ bỏ qua và tiếp tục xử lý cho tới khi kiểm tra tất cả các trạng thái có thể. Về cơ bản thì nó sẽ cố trèo lên đỉnh của ngọn đồi.</p>
	<p class="block_5">Giải thuật simulated annealing</p>
	<p class="block_1">Giải thuật Simulated Annealing cũng là một dạng của local search được biết đến như là một giải thuật tìm kiếm ngẫu nhiên(Stochastic search). Giải thuật tìm kiếm ngẫu nhiên sử dụng một cách rộng rãi trong nhiều lĩnh vực khác nhau như robotics, hóa học(chemistry), y học (medicine) Chế tạo ( manufacturing), kinh tế (economic) và nhiều ngành khác. Chúng ta có thể thực hiện các thứ như tối ưu hóa thiết kế cho robot, xác định thời gian để kiếm soát tự động trong nhà máy, và quy hoạch giao thông. Giải thuật ngẫu nhiên (stochastic algorithms) được sử dụng để giải quyết nhiều vấn đề trong thực tế.</p>
	<p class="block_1"><span class="calibre1">Simulated Annealing là một biến thể của giải thuật Leo đồi (Hill Climbing)  đã nói bên trên. Một trong những vấn đề chính của giải thuật leo đồi là chúng ta leo nhầm đồi giả (false foothills). Nó có nghĩa là chúng ta bị mắc kẹt trong ma trận. Vì vậy tốt hơn là chúng ta phải kiểm tra toàn bộ không gian trước khi chúng ta thực hiên mỗi bước leo. Để đạt được điều này, tất cả không gian phải được khám phá để xem nó thế nào. Nó sẽ giúp chúng ta tránh được bị mắt kẹt ở nơi xa lắm.</span></p>
	<p class="block_1"><span class="calibre1">Trong Simulated Annealing, chúng ta  xây dựng lại vấn đề và giải quyết nó nhanh nhất. Vì vậy bây giờ chúng ta thay vì leo lên núi thì chúng ta đi xuống.  Chúng ta đang làm việc một cách tương tự nhưng theo một cách khác. Chúng ta dùng một hàm để hướng dẫn cho tìm kiếm. Hàm mục tiêu (objective function) </span>phục vụ chúng ta giống hàm heuristic </p>
	<ul class="list_">
	<li class="block_6">Lý do gọi nó là Simulated Annealing (thuật toán mô phỏng luyện kim) bởi vì nó có nguồn gốc từ quá trình luyện kim. Đầu tiên chúng ta làm nóng kim loại và sau đó để chúng nguội cho đến khi chúng đạt đến trạng thái năng lượng tối ưu.</li>
</ul>
	<p class="block_1">Tốc độ chúng ta làm nguội đến khi đạt trạng thái được gọi là annealing schedule. Tốc đọ làm nguội này quan trọng bởi vì nó ảnh hưởng trực tiếp tới kết quả cuối cùng. Trong thực tế khi luyện kim nếu quá trình làm nguội nhanh nó sẽ kết thúc thì quá trình sẽ kết thúc luôn và chúng ta không thể điều khiển trạng thái tối ưu cho kim loại. Ngược lại nếu quá trình này chậm và có thể điều khiển sẽ đưa ra cho chúng ta một miếng kim loại ở trạng thái tối ưu nhất. </p>
	<p class="block_5">Xây dựng chuỗi sử dụng greedy search (tìm kiếm tham lam)</p>
	<p class="block_7">Tính chất lựa chọn tham lam</p>
	<p class="block_8"><span class="text_1">Chúng ta có thể lựa chọn giải pháp nào được cho là tốt nhất ở thời điểm hiện tại và sau đó giải bài toán con nảy sinh từ việc thực hiện lựa chọn vừa rồi. Lựa chọn của thuật toán tham lam có thể phụ thuộc vào các lựa chọn trước đó. Nhưng nó không thể phụ thuộc vào một lựa chọn nào trong tương lai hay phụ thuộc vào lời giải của các bài toán con. Thuật toán tiến triển theo kiểu thực hiện các chọn lựa theo một vòng lặp, cùng lúc đó thu nhỏ bài toán đã cho về một bài toán con nhỏ hơn. Đấy là khác biệt giữa thuật toán này và&nbsp;</span><a href="https://vi.wikipedia.org/wiki/Quy_ho%E1%BA%A1ch_%C4%91%E1%BB%99ng" title="Quy hoạch động" class="text_2">giải thuật quy hoạch động</a><span class="text_1">. Giải thuật quy hoạch động duyệt hết và luôn đảm bảo tìm thấy lời giải. Tại mỗi bước của thuật toán, quy hoạch động đưa ra quyết định dựa trên các quyết định của bước trước, và có thể xét lại đường đi của bước trước hướng tới lời giải. Giải thuật tham lam quyết định sớm và thay đổi đường đi thuật toán theo quyết định đó, và không bao giờ xét lại các quyết định cũ. Đối với một số bài toán, đây có thể là một thuật toán không chính xác. &ndash; Trích wiki</span></p>
	<p class="block_1">Tìm kiếm tham lam <b class="calibre2">(Greedy Search)</b> là một mô hình thuật toán làm cho sự lựa chọn tối ưu ở mỗi thành phần để tìm ra tối ưu tổng thể. Nhưng trong rất nhiều vấn đề, thuật toán tham lam không đưa ra đực giải pháp tổng thể. Một lợi thế của việc sử dụng các thuật toán tham lam là chúng tạo ra một giải pháp gần đúng trong một thời gian hợp lý. Hy vọng điều này gần đúng với giải pháp tối ưu tổng thể.</p>
	<p class="block_1">Các thuật toán tham lam không điều chỉnh các giải pháp của nó dựa trên những thông tin mới có được trong quá trình tìm kiếm. Ví dụ, bạn có kế hoạch đi du lịch và bạn muốn có đường đi tốt nhất ( bài toán bán hàng- <a href="https://vi.wikipedia.org/wiki/B%C3%A0i_to%C3%A1n_ng%C6%B0%E1%BB%9Di_b%C3%A1n_h%C3%A0ng" class="text_3">xem thêm trên wiki</a> ). Nếu bạn sử dụng thuật toán tham lam để lên kế hoạch di chuyển, nó có thể yêu cầu các tuyến đường ngắn nhưng lại có thể mất thời gian di chuyển hơn, hoặc nó cũng có thể dẫn bạn đến những con đường có thể đi nhanh hơn trong thời ngắn nhưng bạn lại có thể bị kẹt xe. Những thứ này hoàn toàn có thể xảy ra vì các thuật toán Tham Lam chỉ nghĩ về các bước đi liên tiếp chứ không phải là giải pháp tổng thể.</p>
	<p class="block_1">Hãy xem làm thế nào để giải quết một vấn đề sử dụng tìm kiếm Tham Lam. Trong vấn đề này chúng ta sẽ cố tạo ra một chuỗi đầu vào (input string) dựa trên bảng chữ cái. Chúng ta sẽ hỏi thuật toán tìm kiếm những giải pháp không gian và xây dựng một con đường tới giải pháp.</p>
	<p class="block_1">Chúng ta sẽ sử dụng một package có tên là <i class="calibre3">simpleai </i>trong suốt chương này . Nó chưa vài hàm khác nhau mà chúng ta sẽ sử dụng thường xuyên trong phần này để xây dựng những giải pháp sử dụng tìm kiếm heuristic. Link github: <a href="https://github.com/simpleai-team/simpleai" class="text_3">https://github.com/simpleai-team/simpleai</a> </p>
	<p class="block_1">Bạn có thể download bản realease 0.8.2 hoặc download tại <a href="file:///D:%5Csimpleai.zip" class="text_3">đây</a> . Unzip và chép folder simpleai vào chung với folder bạn đang code. Giờ thì bạn có thể sử dụng các hàm trong simpleai.</p>
	<p class="block_1">Khi bạn sử dụng PyCharm thì khác 1 chút : Vào Setting-&gt;Project Interpreter -&gt; dấu + (install)</p>
	<p class="block_9">Chọn Manager Repositories ở bên dưới:</p>
	<p class="block_9"><img src="images/000006.png" alt="Image" class="calibre4" /></p>
	<p class="block_9">Chọn dấu + </p>
	<p class="block_9"><img src="images/000007.png" alt="Image" class="calibre5" /></p>
	<p class="block_9">Rồi sau đó cài đặt simpleai như bình thường.</p>
	<p class="block_10">&nbsp;</p>
	<p class="block_1">Giờ thì code nào</p>
	<div class="frame_"><p class="block_11"><span class="text_4">import </span><span class="text_5">argparse<br class="calibre6" /></span><span class="text_4">import </span><span class="text_5">simpleai.search </span><span class="text_4">as </span><span class="text_5">ss<br class="calibre6" /><br class="calibre6" /></span><span class="text_6"># Tạo một hàm để parser tham số input<br class="calibre6" /></span><span class="text_4">def </span><span class="text_7">build_arg_parser</span><span class="text_5">():<br class="calibre6" /><span class="calibre7">    parser=argparse.ArgumentParser(</span></span><span class="text_8">description</span><span class="text_5">=</span><span class="text_9">'Tạo input string sử dụng thuật toán greedy'</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">    parser.add_argument(</span></span><span class="text_9">"--input-string"</span><span class="text_4">,</span><span class="text_8">dest</span><span class="text_5">=</span><span class="text_9">'input_string'</span><span class="text_4">,</span><span class="text_8">required</span><span class="text_5">=</span><span class="text_4">True,</span><span class="text_8">help</span><span class="text_5">=</span><span class="text_9">'Chuỗi nhập'</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">    parser.add_argument(</span></span><span class="text_9">"--initial-state"</span><span class="text_4">,</span><span class="text_8">dest</span><span class="text_5">=</span><span class="text_9">'initial_state'</span><span class="text_4">,</span><span class="text_8">required</span><span class="text_5">=</span><span class="text_4">False,</span><span class="text_8">default</span><span class="text_5">=</span><span class="text_9">''</span><span class="text_4">,</span><span class="text_8">help</span><span class="text_5">=</span><span class="text_9">"Điểm bắt đầu tìm kiếm"</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">return </span><span class="text_5">parser<br class="calibre6" /></span><span class="text_6"># Tạo một class chwuas các thuộc tính cần thiết để giải quyết các vấn đề. Class này thừa kế class SearchProblem trong library simpleai. Method đầu tiên set_target là method chúng ta tạo ra để định nghĩa string target<br class="calibre6" /></span><span class="text_4">class </span><span class="text_5">CustomProblem(ss.SearchProblem):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">set_target</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_4">,</span><span class="text_5">target_string):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_10">self</span><span class="text_5">.target_string=target_string<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Method actions laf method cos sawnx trong SearchProblem và chúng ta cần override nó. Nó chịu trách nhiệm thực hiện các bước để hướng tới kết quả cuối. Nếu độ dài của chuỗi đang tạo ra nhỏ hơn độ dài của chuỗi đích nó sẽ trả về danh sách bảng chữ cái có thể chọn từ đó. Nếu không nó sẽ trả về chuỗi rỗng (empty string):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">actions</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_5">state):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">if </span><span class="text_11">len</span><span class="text_5">(state)&lt;</span><span class="text_11">len</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_5">.target_string):<br class="calibre6" /><span class="calibre7">            alphabets=</span></span><span class="text_9">'abcdefghijklmnopqrstuvwxyz '<br class="calibre6" /><span class="calibre7">            </span></span><span class="text_4">return </span><span class="text_11">list</span><span class="text_5">(alphabets+</span><span class="text_9">''</span><span class="text_5">+alphabets.upper())<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">else</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">            </span></span><span class="text_4">return </span><span class="text_5">[]<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6">#Method resul là một metod có sẵn của SearchProblem và ta override method để tính toán kết quả bằng cách nối các chuỗi và các hành actions đã lấy trước:<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">result</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_5">state</span><span class="text_4">, </span><span class="text_5">action):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">state+action<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Method is_goal là method sẵn có của SearchProblem và nó được sử dụng để kiểm tra xem chúng ta đã đến đích chưa<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">is_goal</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_5">state):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">state==</span><span class="text_10">self</span><span class="text_5">.target_string<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Method heuristic cũng làm method của SearchProblem và chúng ta cũng cần override nó. Chúng ta sẽ định nghĩa lại cái chúng ta cần "khám phá" (heuristic) để giải quyết vấn đề chúng ta gặp phải ( ở đây là xây chuỗi) .<br class="calibre6" /><span class="calibre7">    # Chúng ta sẽ tính toán còn bao nhiêu xa nữa từ trạng thái của chúng ta đang có(current state) để tới đích (goal) và sử dụng số heuristic này để hướng tới đích:</span></span><span class="text_6"><br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">heuristic</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_5">state):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_6"># So sách chuỗi còn lại với chuỗi đích:<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_5">dist=</span><span class="text_11">sum</span><span class="text_5">([</span><span class="text_12">1 </span><span class="text_4">if </span><span class="text_5">state[i]!=</span><span class="text_10">self</span><span class="text_5">.target_string[i] </span><span class="text_4">else </span><span class="text_12">0 </span><span class="text_4">for </span><span class="text_5">i </span><span class="text_4">in </span><span class="text_11">range</span><span class="text_5">(</span><span class="text_11">len</span><span class="text_5">(state))])<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_6"># Khoảng cách độ dài 2 chuỗi<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_5">diff=</span><span class="text_11">len</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_5">.target_string)-</span><span class="text_11">len</span><span class="text_5">(state)<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">dist+diff<br class="calibre6" /><br class="calibre6" /></span><span class="text_6"># Tạo hàm main để lấy tham số input<br class="calibre6" /></span><span class="text_4">if </span><span class="text_5">__name__==</span><span class="text_9">'__main__'</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">    args=build_arg_parser().parse_args()</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">    customProblem=CustomProblem()</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">    customProblem.set_target(args.input_string)</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">    customProblem.initial_state=args.initial_state</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">    output=ss.greedy(customProblem)</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">'Chuỗi cần tạo ra'</span><span class="text_4">,</span><span class="text_5">args.input_string)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">'Các phần giải pháp:'</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">for </span><span class="text_5">item </span><span class="text_4">in </span><span class="text_5">output.path():<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_11">print</span><span class="text_5">(item)</span></p><p class="block_12"></p></div>
	<p class="block_8">&nbsp;</p>
	<p class="block_1">Kết quả nhận được tại Terminal:</p>
	<p class="block_13">greedy_search.py --input-string "Greedy Search" --initial-state ""</p>
	<p class="block_14">Chuỗi cần tạo ra Greedy Search</p>
	<p class="block_14">Các phần giải pháp:</p>
	<p class="block_14">(None, '')</p>
	<p class="block_14">('G', 'G')</p>
	<p class="block_14">('r', 'Gr')</p>
	<p class="block_14">('e', 'Gre')</p>
	<p class="block_14">('e', 'Gree')</p>
	<p class="block_14">('d', 'Greed')</p>
	<p class="block_14">('y', 'Greedy')</p>
	<p class="block_14">(' ', 'Greedy ')</p>
	<p class="block_14">('S', 'Greedy S')</p>
	<p class="block_14">('e', 'Greedy Se')</p>
	<p class="block_14">('a', 'Greedy Sea')</p>
	<p class="block_14">('r', 'Greedy Sear')</p>
	<p class="block_14">('c', 'Greedy Searc')</p>
	<p class="block_15">('h', 'Greedy Search')</p>
	<p class="block_8">&nbsp;</p>
	<p class="block_5">Giải quyết một vấn đề cùng với ràng buộc</p>
	<p class="block_1">Chúng ta đã bàn luận về CSPs. Bây giờ chúng ta thử ứng dụng chúng vào thực tế. Chúng ta có một danh sách gồm các tên và mỗi tên này chỉ có thể lấy một giá trị xác định. Chúng ta cũng có một bộ số ràng buộc với những người đó phải thỏa mãn. </p>
	<div class="frame_1"><p class="block_11"><span class="text_4">from </span><span class="text_5">simpleai.search </span><span class="text_4">import </span><span class="text_5">CspProblem</span><span class="text_4">,</span><span class="text_5">backtrack</span><span class="text_4">,</span><span class="text_5">min_conflicts</span><span class="text_4">,</span><span class="text_5">MOST_CONSTRAINED_VARIABLE</span><span class="text_4">,</span><span class="text_5">HIGHEST_DEGREE_VARIABLE</span><span class="text_4">,</span><span class="text_5">LEAST_CONSTRAINING_VALUE<br class="calibre6" /><br class="calibre6" /></span><span class="text_6"># Tạo ràng buộc (contraint-ràng buộc) thứ 1 yêu cầu tất cả các biến trong danh sách input phải là giá trị duy nhất:<br class="calibre6" /></span><span class="text_4">def </span><span class="text_7">constraint_unique</span><span class="text_5">(</span><span class="text_6">variables</span><span class="text_4">,</span><span class="text_5">values):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6">#Kiểm tra xem tất cả các giá trị có phải là duy nhất<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">return </span><span class="text_11">len</span><span class="text_5">(values)==</span><span class="text_11">len</span><span class="text_5">(</span><span class="text_11">set</span><span class="text_5">(values))<br class="calibre6" /></span><span class="text_6"># Tạo ràng buộc thứ 2 yêu cầu biến đầu tiên phải có giá trị lớn hơn biến thứ 2<br class="calibre6" /></span><span class="text_4">def </span><span class="text_7">constraint_bigger</span><span class="text_5">(</span><span class="text_6">variables</span><span class="text_4">,</span><span class="text_5">values):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">return </span><span class="text_5">values[</span><span class="text_12">0</span><span class="text_5">]&gt;values[</span><span class="text_12">1</span><span class="text_5">]<br class="calibre6" /></span><span class="text_6"># Tạo ràng buộc thứ 3 : yêu cầu nếu giá trị biến đầu tiên phải là số lẻ,và giá trị của biến thứ 2 phải là số chẵn và ngược lại:<br class="calibre6" /></span><span class="text_4">def </span><span class="text_7">contraint_odd_even</span><span class="text_5">(</span><span class="text_6">variables</span><span class="text_4">,</span><span class="text_5">values):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">if </span><span class="text_5">values[</span><span class="text_12">0</span><span class="text_5">]%</span><span class="text_12">2</span><span class="text_5">==</span><span class="text_12">0</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">values[</span><span class="text_12">1</span><span class="text_5">]%</span><span class="text_12">2</span><span class="text_5">==</span><span class="text_12">1<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">else</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">values[</span><span class="text_12">1</span><span class="text_5">]%</span><span class="text_12">2</span><span class="text_5">==</span><span class="text_12">0<br class="calibre6" /></span><span class="text_6"># Tạo hàm main<br class="calibre6" /></span><span class="text_4">if </span><span class="text_5">__name__==</span><span class="text_9">'__main__'</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">    variables=(</span></span><span class="text_9">'Tèo'</span><span class="text_4">,</span><span class="text_9">'Tý'</span><span class="text_4">,</span><span class="text_9">'Sửu'</span><span class="text_4">,</span><span class="text_9">'Dậu'</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6">#Tạo danh sách giá trị mà mỗi biến tên có thể lấy<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">domain={<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_9">'Tèo'</span><span class="text_5">:[</span><span class="text_12">1</span><span class="text_4">,</span><span class="text_12">2</span><span class="text_4">,</span><span class="text_12">3</span><span class="text_5">]</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_9">'Tý'</span><span class="text_5">:[</span><span class="text_12">1</span><span class="text_4">,</span><span class="text_12">3</span><span class="text_5">]</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_9">'Sửu'</span><span class="text_5">:[</span><span class="text_12">2</span><span class="text_4">,</span><span class="text_12">4</span><span class="text_5">]</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_9">'Dậu'</span><span class="text_5">:[</span><span class="text_12">2</span><span class="text_4">,</span><span class="text_12">3</span><span class="text_4">,</span><span class="text_12">4</span><span class="text_5">]}</span></p><p class="block_16">Tạo vài kịch bản ràng buộc cho. Trong trường hợp này chúng ta sẽ có 3 ràng buộc như sau</p><li class="block_17">Tèo, Tý, Sửu phải có các giá trị khác nhau</li>
	<li class="block_17">Giá trị của Sửu phải lớn hơn giá trị của Tý</li>
	<li class="block_17">Nếu giá trị của Tèo là lẻ thì giá trị của Dậu phải là giá trị chẵn và ngược lại</li>
<p class="block_18"><span class="text_5"><br class="calibre6" /><span class="calibre7">    contraints=[</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">       ((</span></span><span class="text_9">'Tèo'</span><span class="text_4">,</span><span class="text_9">'Tý'</span><span class="text_4">,</span><span class="text_9">'Sửu'</span><span class="text_5">)</span><span class="text_4">,</span><span class="text_5">constraint_unique)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">       </span></span><span class="text_5">((</span><span class="text_9">'Sửu'</span><span class="text_4">,</span><span class="text_9">'Tý'</span><span class="text_5">)</span><span class="text_4">,</span><span class="text_5">constraint_bigger)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">       </span></span><span class="text_5">((</span><span class="text_9">'Tèo'</span><span class="text_4">,</span><span class="text_9">'Dậu'</span><span class="text_5">)</span><span class="text_4">,</span><span class="text_5">contraint_odd_even)<br class="calibre6" /><span class="calibre7">   ]</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">   </span></span><span class="text_6"># Sử dụng các biến và các ràng buộc để tạo 1 object CspProblem:<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">problem=CspProblem(variables</span><span class="text_4">,</span><span class="text_5">domain</span><span class="text_4">,</span><span class="text_5">contraints)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Tính toán các giải pháp và in nó ra Terminal:<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">"Các giải pháp:</span><span class="text_4">\n\n</span><span class="text_9">Normal:"</span><span class="text_4">,</span><span class="text_5">backtrack(problem))<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Tính toán các giải pháp sử dụng MOST_CONSTRAINED_VARIABLE<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">"MOST_CONSTRAINED_VARIABLE:"</span><span class="text_4">,</span><span class="text_5">backtrack(problem</span><span class="text_4">,</span><span class="text_8">value_heuristic</span><span class="text_5">=MOST_CONSTRAINED_VARIABLE))<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">"HIGHEST_DEGREE_VARIABLE:"</span><span class="text_4">,</span><span class="text_5">backtrack(problem</span><span class="text_4">,</span><span class="text_8">value_heuristic</span><span class="text_5">=HIGHEST_DEGREE_VARIABLE))<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">"LEAST_CONSTRAINING_VALUE"</span><span class="text_4">,</span><span class="text_5">backtrack(problem</span><span class="text_4">,</span><span class="text_8">value_heuristic</span><span class="text_5">=LEAST_CONSTRAINING_VALUE))<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Sử dụng kết hợp variable_heuristic và value_heuristic<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">"MOST_CONSTRAINED_VARIABLE,LEAST_CONSTRAINING_VALUE"</span><span class="text_4">,</span><span class="text_5">backtrack(problem</span><span class="text_4">,</span><span class="text_8">variable_heuristic</span><span class="text_5">=MOST_CONSTRAINED_VARIABLE</span><span class="text_4">,</span><span class="text_8">value_heuristic</span><span class="text_5">=LEAST_CONSTRAINING_VALUE))<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">"HIGHEST_DEGREE_VARIABLE,LEAST_CONSTRAINING_VALUE"</span><span class="text_4">,</span><span class="text_5">backtrack(problem</span><span class="text_4">,</span><span class="text_8">variable_heuristic</span><span class="text_5">=HIGHEST_DEGREE_VARIABLE</span><span class="text_4">,</span><span class="text_8">value_heuristic</span><span class="text_5">=LEAST_CONSTRAINING_VALUE))<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6">#Tính toán các giải pháp sử dụng minimum conflicts heuristic:<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">"Minimum conflicts:"</span><span class="text_4">,</span><span class="text_5">min_conflicts(problem))</span></p><p class="block_12"></p></div>
	<ul class="list_">
	</ul>
	<p class="block_8">&nbsp;</p>
	<p class="block_1">Kết quả thu được tại output:</p>
	<p class="block_13">Các giải pháp:</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Normal: {'Tèo': 1, 'Tý': 3, 'Sửu': 4, 'Dậu': 2}</p>
	<p class="block_14">MOST_CONSTRAINED_VARIABLE: {'Tèo': 1, 'Tý': 3, 'Sửu': 4, 'Dậu': 2}</p>
	<p class="block_14">HIGHEST_DEGREE_VARIABLE: {'Tèo': 1, 'Tý': 3, 'Sửu': 4, 'Dậu': 2}</p>
	<p class="block_14">LEAST_CONSTRAINING_VALUE {'Tèo': 1, 'Tý': 3, 'Sửu': 4, 'Dậu': 2}</p>
	<p class="block_14">MOST_CONSTRAINED_VARIABLE,LEAST_CONSTRAINING_VALUE {'Tý': 1, 'Sửu': 2, 'Tèo': 3, 'Dậu': 2}</p>
	<p class="block_14">HIGHEST_DEGREE_VARIABLE,LEAST_CONSTRAINING_VALUE {'Tèo': 1, 'Tý': 3, 'Sửu': 4, 'Dậu': 2}</p>
	<p class="block_15">Minimum conflicts: {'Tèo': 3, 'Tý': 1, 'Sửu': 4, 'Dậu': 2}</p>
	<p class="block_5">Giải quyết vấn đề tô màu từng vùng</p>
	<p class="block_1">Giờ thử sử dụng thuật toán thỏa mãn ràng buộc để giải quyết vấn đề tô màu.</p>
	<p class="block_1">Hãy thử xem hình phía dưới:</p>
	<p class="block_9"><img src="images/000001.png" alt="Image" class="calibre8" /></p>
	<p class="block_1">Chúng ta có vài vùng và ứng với mỗi vùng được dán nhãn (labeled) bởi các tền khác nhau. Nhiệm vụ của chúng ta là tô màu tất cả các vùng bằng 4 màu, và chúng phải thỏa mãn điều kiện ràng buộc là 2 vùng nằm kề nhau không được trùng màu nhau:</p>
	<div class="frame_"><p class="block_11"><span class="text_4">from </span><span class="text_13">simpleai.search </span><span class="text_4">import </span><span class="text_13">CspProblem</span><span class="text_4">,</span><span class="text_13">backtrack<br class="calibre6" /><br class="calibre6" /></span><span class="text_5"># Tạo hàm ràng buộc yêu cầu giá trị phải khác nhau<br class="calibre6" /></span><span class="text_4">def </span><span class="text_7">constraint_func</span><span class="text_13">(</span><span class="text_5">variables</span><span class="text_4">,</span><span class="text_13">values):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">return </span><span class="text_13">values[</span><span class="text_12">0</span><span class="text_13">]!=values[</span><span class="text_12">1</span><span class="text_13">]<br class="calibre6" /></span><span class="text_5"># Tạo hàm main<br class="calibre6" /></span><span class="text_4">if </span><span class="text_13">__name__==</span><span class="text_9">'__main__'</span><span class="text_13">:<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5"># tạo variables cần thiết<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_13">names = (</span><span class="text_9">'Mark'</span><span class="text_4">, </span><span class="text_9">'Julia'</span><span class="text_4">, </span><span class="text_9">'Steve'</span><span class="text_4">, </span><span class="text_9">'Amanda'</span><span class="text_4">, </span><span class="text_9">'Brian'</span><span class="text_4">, </span><span class="text_9">'Joanne'</span><span class="text_4">, </span><span class="text_9">'Derek'</span><span class="text_4">, </span><span class="text_9">'Allan'</span><span class="text_4">, </span><span class="text_9">'Michelle'</span><span class="text_4">, </span><span class="text_9">'Kelly'</span><span class="text_13">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5"># Tạo values với giá trị là các màu cho trước<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_13">colors = </span><span class="text_11">dict</span><span class="text_13">((name</span><span class="text_4">, </span><span class="text_13">[</span><span class="text_9">'red'</span><span class="text_4">, </span><span class="text_9">'green'</span><span class="text_4">, </span><span class="text_9">'blue'</span><span class="text_4">, </span><span class="text_9">'gray'</span><span class="text_13">]) </span><span class="text_4">for </span><span class="text_13">name </span><span class="text_4">in </span><span class="text_13">names)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5"># Chúng ta cần chuyển đổi thông tin đã có vào một thứ để thuật toán có thể hiểu<br class="calibre6" /><span class="calibre7">    # Tạo một ràng buộc điều kiện yêu cầu danh sách những người nằm kế </span></span><span class="text_5">nhau trên bản đồ không có màu trùng nhau<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_13">constraints=[<br class="calibre6" /><span class="calibre7">        ((</span></span><span class="text_9">'Mark'</span><span class="text_4">, </span><span class="text_9">'Julia'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">, </span><span class="text_13">((</span><span class="text_9">'Mark'</span><span class="text_4">, </span><span class="text_9">'Steve'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">((</span><span class="text_9">'Julia'</span><span class="text_4">, </span><span class="text_9">'Steve'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">, </span><span class="text_13">((</span><span class="text_9">'Julia'</span><span class="text_4">, </span><span class="text_9">'Amanda'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">((</span><span class="text_9">'Julia'</span><span class="text_4">, </span><span class="text_9">'Derek'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">, </span><span class="text_13">((</span><span class="text_9">'Julia'</span><span class="text_4">, </span><span class="text_9">'Brian'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">((</span><span class="text_9">'Steve'</span><span class="text_4">, </span><span class="text_9">'Amanda'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">, </span><span class="text_13">((</span><span class="text_9">'Steve'</span><span class="text_4">, </span><span class="text_9">'Allan'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">((</span><span class="text_9">'Steve'</span><span class="text_4">, </span><span class="text_9">'Michelle'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">, </span><span class="text_13">((</span><span class="text_9">'Amanda'</span><span class="text_4">, </span><span class="text_9">'Michelle'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">((</span><span class="text_9">'Amanda'</span><span class="text_4">, </span><span class="text_9">'Joanne'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">, </span><span class="text_13">((</span><span class="text_9">'Amanda'</span><span class="text_4">, </span><span class="text_9">'Derek'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">((</span><span class="text_9">'Brian'</span><span class="text_4">, </span><span class="text_9">'Derek'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">, </span><span class="text_13">((</span><span class="text_9">'Brian'</span><span class="text_4">, </span><span class="text_9">'Kelly'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">((</span><span class="text_9">'Joanne'</span><span class="text_4">, </span><span class="text_9">'Michelle'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">, </span><span class="text_13">((</span><span class="text_9">'Joanne'</span><span class="text_4">, </span><span class="text_9">'Amanda'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">((</span><span class="text_9">'Joanne'</span><span class="text_4">, </span><span class="text_9">'Derek'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">, </span><span class="text_13">((</span><span class="text_9">'Joanne'</span><span class="text_4">, </span><span class="text_9">'Kelly'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">((</span><span class="text_9">'Derek'</span><span class="text_4">, </span><span class="text_9">'Kelly'</span><span class="text_13">)</span><span class="text_4">, </span><span class="text_13">constraint_func)</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_13">]<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5"># Sử dụng variables ( tên - name) và domain (colors) biến constraints vừa tạo làm tham số cho hàm CspProblem<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_13">problem=CspProblem(names</span><span class="text_4">,</span><span class="text_13">colors</span><span class="text_4">,</span><span class="text_13">constraints)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5"># Giải quyết vấn đề và in ra phương pháp :<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_13">output=backtrack(problem)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_13">(</span><span class="text_9">'</span><span class="text_4">\n</span><span class="text_9">Color mapping:</span><span class="text_4">\n</span><span class="text_9">'</span><span class="text_13">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">for </span><span class="text_13">k</span><span class="text_4">, </span><span class="text_13">v </span><span class="text_4">in </span><span class="text_13">output.items():<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_11">print</span><span class="text_13">(k</span><span class="text_4">, </span><span class="text_9">'==&gt;'</span><span class="text_4">, </span><span class="text_13">v)</span></p><p class="block_12"></p></div>
	<p class="block_1">Kết quả thu được tại Terminal:</p>
	<p class="block_13">Color mapping:</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Mark ==&gt; red</p>
	<p class="block_14">Julia ==&gt; green</p>
	<p class="block_14">Steve ==&gt; blue</p>
	<p class="block_14">Amanda ==&gt; red</p>
	<p class="block_14">Brian ==&gt; red</p>
	<p class="block_14">Joanne ==&gt; green</p>
	<p class="block_14">Derek ==&gt; blue</p>
	<p class="block_14">Allan ==&gt; red</p>
	<p class="block_14">Michelle ==&gt; gray</p>
	<p class="block_15">Kelly ==&gt; gray</p>
	<p class="block_8">&nbsp;</p>
	<p class="block_1">Nếu tô màu theo kết quả cho hình vẽ ban đầu ta sẽ có hình vẽ như sau</p>
	<p class="block_8">&nbsp;</p>
	<p class="block_9"><img src="images/000000.png" alt="Image" class="calibre9" /></p>
	<p class="block_8">&nbsp;</p>
	<p class="block_8">&nbsp;</p>
	<p class="block_5">Xây dựng bộ giải mã game câu đố 8-Puzzle</p>
	<p class="block_1">8-Puzzle là biến thể của game 15-Puzzle. Bạn có thể xem nó ở đây: <a href="https://en.wikipedia.org/wiki/15_puzzle." class="text_3">https://en.wikipedia.org/wiki/15_puzzle.</a> Bạn sẽ có một lưới ngẫu nhiên gồm các con số trên đó và xắp xếp sao cho chúng có giá trị từ nhỏ đến lớn. Nó khá giống với game trượt ô xếp hình chúng ta thường chơi cách đây khoảng 20 năm :D :</p>
	<p class="block_9"><img src="images/00003.jpeg" alt="HÃ¬nh áº£nh cÃ³ liÃªn quan" class="calibre10" /><span class="calibre1">            còn game chúng ta có </span><img src="images/000005.png" alt="Image" class="calibre11" />dạng thế này </p>
	<p class="block_1">Chúng ta sẽ sử dụng thuật toán <b class="calibre2">A* </b>để giải quyết vấn đề. Nó là một thuật toán được sử dụng đề tìm kiếm giải pháp đường đi . Thuật toán này là thuật toán kết hợp giữa 2 thuật toán <b class="calibre2">Dijkstra's algorithm </b>và thuật toán search tham lam ( greedy best-first search). Thay vì không mù quáng đi lang thang thì thuật toán A* sẽ chọn một đường đi "đầy hứa hẹn". Tại mỗi điểm, Chúng ta tạo ra một danh sách tất cả các khả năng và sau đó chọn một cái có giá trị thấp nhất thỏa mãn điều kiện của chúng ta.</p>
	<p class="block_1">Giờ thì làm sao để tính giá trị thấp nhất tại 1 điểm. Tại mỗi điểm chúng ta cần tính giá trị. Giá trị này dựa trên tổng số của 2 giá trị - Giá trị đầu tiên là giá trị lấy được tại điểm hiện tại và giá trị thứ 2 là giá trị thứ 2 là giá trị đạt đến điểm đích tính từ giá trị hiện tại. Chúng ta sử dụng phép tổng này giống như là số heuristic của chúng ta. Giống như đã biets thì giá trị thứ 2 về cơ bản không phải là tính toán hoàn hảo. Nếu nó là hoàn hảo thì thuật toán A* sẽ tìm được giải pháp nhanh chóng. Nhưng thường thì nó sẽ phải mất vài lần để tìm kiếm đường đi đến đích. Nhưng thuật toán A* rất hiệu quả trong việc tìm kiếm đường đi tối ưu và nó là một trong những giải thuật thông dụng nhất trong trường hợp này. </p>
	<p class="block_1">Giờ thì sử dụng thuật toán A* để xây dựng một máy giải toán cho câu đó 8-Puzzle. Đây là một biến thể của các giải pháp được đưa ra trong simpleai.</p>
	<div class="frame_"><p class="block_11"><span class="text_4">from </span><span class="text_5">simpleai.search </span><span class="text_4">import </span><span class="text_5">astar</span><span class="text_4">,</span><span class="text_5">SearchProblem<br class="calibre6" /><br class="calibre6" /></span><span class="text_6">## Tạo một hàm để chuyển đổi giữa list và tring<br class="calibre6" /></span><span class="text_4">def </span><span class="text_7">string_to_list</span><span class="text_5">(input):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">if </span><span class="text_11">isinstance</span><span class="text_5">(input</span><span class="text_4">,</span><span class="text_11">str</span><span class="text_5">):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">[x.split(</span><span class="text_9">'-'</span><span class="text_5">) </span><span class="text_4">for </span><span class="text_5">x </span><span class="text_4">in </span><span class="text_5">input.split(</span><span class="text_9">'</span><span class="text_4">\n</span><span class="text_9">'</span><span class="text_5">)]<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">else</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_9">'</span><span class="text_4">\n</span><span class="text_9">'</span><span class="text_5">.join([</span><span class="text_9">'-'</span><span class="text_5">.join(x) </span><span class="text_4">for </span><span class="text_5">x </span><span class="text_4">in </span><span class="text_5">input])<br class="calibre6" /></span><span class="text_6"># Tạo hàm kiểm tra vị trí của một ô trong lưới 8x8<br class="calibre6" /></span><span class="text_4">def </span><span class="text_7">get_location</span><span class="text_5">(rows</span><span class="text_4">,</span><span class="text_5">input_element):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">for </span><span class="text_5">i</span><span class="text_4">,</span><span class="text_5">row </span><span class="text_4">in </span><span class="text_11">enumerate</span><span class="text_5">(rows):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">for </span><span class="text_5">j</span><span class="text_4">,</span><span class="text_5">item </span><span class="text_4">in </span><span class="text_11">enumerate</span><span class="text_5">(row):<br class="calibre6" /><span class="calibre7">            </span></span><span class="text_4">if </span><span class="text_5">item==input_element:<br class="calibre6" /><span class="calibre7">                </span></span><span class="text_4">return </span><span class="text_5">i</span><span class="text_4">,</span><span class="text_5">j<br class="calibre6" /></span><span class="text_6">#Định nghĩa đích đến cần đạt được<br class="calibre6" /></span><span class="text_5">GOAL = </span><span class="text_9">'''1-2-3<br class="calibre6" />4-5-6<br class="calibre6" />7-8-e'''<br class="calibre6" /></span><span class="text_6"># Tạo vị trí đích đến cho mỗi số để tính khoảng cách<br class="calibre6" /></span><span class="text_5">goal_positions = {}<br class="calibre6" />rows_goal = string_to_list(GOAL)<br class="calibre6" /></span><span class="text_4">for </span><span class="text_5">number </span><span class="text_4">in </span><span class="text_9">'12345678e'</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">    goal_positions[number] = get_location(rows_goal</span></span><span class="text_4">, </span><span class="text_5">number)<br class="calibre6" /><br class="calibre6" /></span><span class="text_6"># Tạo class PuzzleSolver chứa các thuộc tính để giải quyết bài toán. class này kế thừa từ class SearchProblem<br class="calibre6" /></span><span class="text_4">class </span><span class="text_5">PuzzleSolver(SearchProblem):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6">#Method actions để lấy danh sách các ô có thể di chuyển tới ô khoảng trống<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">actions</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_5">state):<br class="calibre6" /><span class="calibre7">        rows=string_to_list(state)</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">        row_empty</span></span><span class="text_4">,</span><span class="text_5">col_empty=get_location(rows</span><span class="text_4">,</span><span class="text_9">'e'</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_6"># kiểm tra vị trí của ô tróng và tạo action mới:<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_5">actions=[]<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">if </span><span class="text_5">row_empty&gt;</span><span class="text_12">0</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">            actions.append(rows[row_empty-</span></span><span class="text_12">1</span><span class="text_5">][col_empty])<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">if </span><span class="text_5">row_empty&lt;</span><span class="text_12">2</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">            actions.append(rows[row_empty+</span></span><span class="text_12">1</span><span class="text_5">][col_empty])<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">if </span><span class="text_5">col_empty&gt;</span><span class="text_12">0</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">            actions.append(rows[row_empty][col_empty-</span></span><span class="text_12">1</span><span class="text_5">])<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">if </span><span class="text_5">col_empty&lt;</span><span class="text_12">2</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">            actions.append(rows[row_empty][col_empty+</span></span><span class="text_12">1</span><span class="text_5">])<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">actions<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Override Method result. Chuyển đổi những chuỗi thành list và lấy vị trí của ô trống. Tạo ra kết quả (result) bằng cách cập nhật vị trí:<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">result</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_5">state</span><span class="text_4">, </span><span class="text_5">action):<br class="calibre6" /><span class="calibre7">        rows=string_to_list(state)</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">        row_empty</span></span><span class="text_4">,</span><span class="text_5">col_empty=get_location(rows</span><span class="text_4">,</span><span class="text_9">'e'</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">        row_new</span></span><span class="text_4">,</span><span class="text_5">col_new=get_location(rows</span><span class="text_4">,</span><span class="text_5">action)<br class="calibre6" /><span class="calibre7">        rows[row_empty][col_empty]</span></span><span class="text_4">,</span><span class="text_5">rows[row_new][col_new]=rows[row_new][col_new]</span><span class="text_4">,</span><span class="text_5">rows[row_empty][col_empty]<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">string_to_list(rows)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Kiểm tra nếu đã đến được đích<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">is_goal</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_5">state):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">state==GOAL<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Method heuristic. Chúng ta sử dụng heuristic để tính toán khoảng cách từ trạng thái hiện tại đến trạng thái đích sử dụng phép tính khoảng cách Mahattan<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">heuristic</span><span class="text_5">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_5">state):<br class="calibre6" /><span class="calibre7">        rows=string_to_list(state)</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">        distance=</span></span><span class="text_12">0<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">for </span><span class="text_5">number </span><span class="text_4">in </span><span class="text_9">'12345678e'</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">            row_new</span></span><span class="text_4">,</span><span class="text_5">col_new=get_location(rows</span><span class="text_4">,</span><span class="text_5">number)<br class="calibre6" /><span class="calibre7">            row_new_goal</span></span><span class="text_4">,</span><span class="text_5">col_new_goal=goal_positions[number]<br class="calibre6" /><span class="calibre7">            distance+=</span></span><span class="text_11">abs</span><span class="text_5">(row_new-row_new_goal)+</span><span class="text_11">abs</span><span class="text_5">(col_new-col_new_goal)<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_5">distance<br class="calibre6" /><br class="calibre6" /></span><span class="text_6"># Sử dụng A* để khởi tạo vị trí ban đầu<br class="calibre6" /></span><span class="text_5">INITIAL = \<br class="calibre6" /></span><span class="text_9">'''4-e-3<br class="calibre6" />7-1-5<br class="calibre6" />6-8-2'''<br class="calibre6" /></span><span class="text_5">problem=PuzzleSolver(INITIAL)<br class="calibre6" />result=astar(problem)<br class="calibre6" /></span><span class="text_6"># In các bước đi<br class="calibre6" /></span><span class="text_4">for </span><span class="text_5">i</span><span class="text_4">,</span><span class="text_5">(action</span><span class="text_4">,</span><span class="text_5">state) </span><span class="text_4">in </span><span class="text_11">enumerate</span><span class="text_5">(result.path()):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">()<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">if </span><span class="text_5">action==</span><span class="text_4">None</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">'Hình khởi tạo ban đầu'</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">elif </span><span class="text_5">i==</span><span class="text_11">len</span><span class="text_5">(result.path())-</span><span class="text_12">1</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">'Sau khi di chuyển ô'</span><span class="text_4">,</span><span class="text_5">action</span><span class="text_4">,</span><span class="text_9">'Vào vị trí ô trống. DONE: '</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">else</span><span class="text_5">:<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_11">print</span><span class="text_5">(</span><span class="text_9">'Sau khi di chuyển ô'</span><span class="text_4">, </span><span class="text_5">action</span><span class="text_4">, </span><span class="text_9">'Vào vị trí ô trống. Ta có'</span><span class="text_5">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_5">(state)</span></p><p class="block_12"></p></div>
	<p class="block_8">&nbsp;</p>
	<p class="block_1">Kết quả từng bước được in ra Terminal:</p>
	<p class="block_13">Hình khởi tạo ban đầu</p>
	<p class="block_14">4-e-3</p>
	<p class="block_14">7-1-5</p>
	<p class="block_14">6-8-2</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 1 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">4-1-3</p>
	<p class="block_14">7-e-5</p>
	<p class="block_14">6-8-2</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 8 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">4-1-3</p>
	<p class="block_14">7-8-5</p>
	<p class="block_14">6-e-2</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 6 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">4-1-3</p>
	<p class="block_14">7-8-5</p>
	<p class="block_14">e-6-2</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 7 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">4-1-3</p>
	<p class="block_14">e-8-5</p>
	<p class="block_14">7-6-2</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 4 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">e-1-3</p>
	<p class="block_14">4-8-5</p>
	<p class="block_14">7-6-2</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 1 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-e-3</p>
	<p class="block_14">4-8-5</p>
	<p class="block_14">7-6-2</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 3 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-3-e</p>
	<p class="block_14">4-8-5</p>
	<p class="block_14">7-6-2</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 5 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-3-5</p>
	<p class="block_14">4-8-e</p>
	<p class="block_14">7-6-2</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 2 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-3-5</p>
	<p class="block_14">4-8-2</p>
	<p class="block_14">7-6-e</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 6 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-3-5</p>
	<p class="block_14">4-8-2</p>
	<p class="block_14">7-e-6</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 8 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-3-5</p>
	<p class="block_14">4-e-2</p>
	<p class="block_14">7-8-6</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 2 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-3-5</p>
	<p class="block_14">4-2-e</p>
	<p class="block_14">7-8-6</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 5 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-3-e</p>
	<p class="block_14">4-2-5</p>
	<p class="block_14">7-8-6</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 3 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-e-3</p>
	<p class="block_14">4-2-5</p>
	<p class="block_14">7-8-6</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 2 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-2-3</p>
	<p class="block_14">4-e-5</p>
	<p class="block_14">7-8-6</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 5 Vào vị trí ô trống. Ta có</p>
	<p class="block_14">1-2-3</p>
	<p class="block_14">4-5-e</p>
	<p class="block_14">7-8-6</p>
	<p class="block_19">&nbsp;</p>
	<p class="block_14">Sau khi di chuyển ô 6 Vào vị trí ô trống. DONE: </p>
	<p class="block_14">1-2-3</p>
	<p class="block_14">4-5-6</p>
	<p class="block_15">7-8-e</p>
	<p class="block_8">&nbsp;</p>
	<p class="block_1">Thực hiện theo từng bước trên bạn sẽ giải được game: hãy thử chơi game ở đây: <a href="http://mypuzzle.org/sliding" class="text_3">http://mypuzzle.org/sliding</a></p>
	<p class="block_5">Xây dựng một bộ giải mã trò chơi mê cung:</p>
	<p class="block_1">Giờ thì dùng thuật toán A* để giải quyết mê cung sau:</p>
	<p class="block_9"><img src="images/000004.png" alt="Image" class="calibre12" /></p>
	<p class="block_1">Hình # là những vật cản của mê cung. Hình o là điểm bắt đầu và x là điểm kết thúc. Giờ thì ta hãy sử dụng SearchProblem và A* để giải quyết vấn đề này bằng Python</p>
	<p class="block_8">&nbsp;</p>
	<div class="frame_"><p class="block_11"><span class="text_4">import </span><span class="text_13">math<br class="calibre6" /></span><span class="text_4">from </span><span class="text_13">simpleai.search </span><span class="text_4">import </span><span class="text_13">SearchProblem</span><span class="text_4">,</span><span class="text_13">astar<br class="calibre6" /><br class="calibre6" /></span><span class="text_6">#Tạo Map<br class="calibre6" /></span><span class="text_13">MAP = </span><span class="text_5">"""<br class="calibre6" />##############################<br class="calibre6" /><span class="calibre7">#         #              #   #</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7"># ####    ########       #   #</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">#  o #    #              #   #</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">#    ###     #####  ######   #</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">#      #   ###   #           #</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">#      #     #   #  #  #   ###</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">#     #####    #    #  # x   #</span></span><span class="text_5"><br class="calibre6" /><span class="calibre7">#              #       #     #</span></span><span class="text_5"><br class="calibre6" />##############################<br class="calibre6" />"""<br class="calibre6" /></span><span class="text_6">#Chuyển Map thành list<br class="calibre6" /><br class="calibre6" /></span><span class="text_13">MAP=[</span><span class="text_11">list</span><span class="text_13">(x) </span><span class="text_4">for </span><span class="text_13">x </span><span class="text_4">in </span><span class="text_13">MAP.split(</span><span class="text_5">"</span><span class="text_4">\n</span><span class="text_5">"</span><span class="text_13">) </span><span class="text_4">if </span><span class="text_13">x]<br class="calibre6" /></span><span class="text_6">#đinh giá để di chuyển xung quanh map. Di chuyển chéo thì sẽ cao hơn là di chuyển theo hướng thẳng.<br class="calibre6" /></span><span class="text_13">cost_regular=</span><span class="text_12">1.0<br class="calibre6" /></span><span class="text_13">cost_diagonal=</span><span class="text_12">1.7<br class="calibre6" /></span><span class="text_6">#Gắn giá vào hướng di chuyển tương ứng<br class="calibre6" /></span><span class="text_13">COST={<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">"up"</span><span class="text_13">:cost_regular</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">"down"</span><span class="text_13">:cost_regular</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">"left"</span><span class="text_13">:cost_regular</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">"right"</span><span class="text_13">:cost_regular</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">"up left"</span><span class="text_13">:cost_diagonal</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">"up right"</span><span class="text_13">:cost_diagonal</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">"down left"</span><span class="text_13">:cost_diagonal</span><span class="text_4">,<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_5">"down right"</span><span class="text_13">:cost_diagonal</span><span class="text_4">,<br class="calibre6" /></span><span class="text_13">}<br class="calibre6" /></span><span class="text_6">#Tạo Class MazeSolver thừa kế class SearchProblem<br class="calibre6" /></span><span class="text_4">class </span><span class="text_13">MazeSolver(SearchProblem):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_14">__init__</span><span class="text_13">(</span><span class="text_10">self</span><span class="text_4">,</span><span class="text_13">board):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_10">self</span><span class="text_13">.board=board<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_10">self</span><span class="text_13">.goal=(</span><span class="text_12">0</span><span class="text_4">,</span><span class="text_12">0</span><span class="text_13">)<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_6">#Tách những khối ban đầu và vị trí kết thúc:<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">for </span><span class="text_13">y </span><span class="text_4">in </span><span class="text_11">range</span><span class="text_13">(</span><span class="text_11">len</span><span class="text_13">(</span><span class="text_10">self</span><span class="text_13">.board)):<br class="calibre6" /><span class="calibre7">            </span></span><span class="text_4">for </span><span class="text_13">x </span><span class="text_4">in </span><span class="text_11">range</span><span class="text_13">(</span><span class="text_11">len</span><span class="text_13">(</span><span class="text_10">self</span><span class="text_13">.board[y])):<br class="calibre6" /><span class="calibre7">                </span></span><span class="text_4">if </span><span class="text_10">self</span><span class="text_13">.board[y][x].lower()==</span><span class="text_5">"o"</span><span class="text_13">:<br class="calibre6" /><span class="calibre7">                    </span></span><span class="text_10">self</span><span class="text_13">.initial=(x</span><span class="text_4">,</span><span class="text_13">y)<br class="calibre6" /><span class="calibre7">                </span></span><span class="text_4">elif </span><span class="text_10">self</span><span class="text_13">.board[y][x].lower()==</span><span class="text_5">"x"</span><span class="text_13">:<br class="calibre6" /><span class="calibre7">                    </span></span><span class="text_10">self</span><span class="text_13">.goal=(x</span><span class="text_4">,</span><span class="text_13">y)<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_11">super</span><span class="text_13">(MazeSolver</span><span class="text_4">,</span><span class="text_10">self</span><span class="text_13">).</span><span class="text_14">__init__</span><span class="text_13">(</span><span class="text_8">initial_state</span><span class="text_13">=</span><span class="text_10">self</span><span class="text_13">.initial)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Override method actions, tại mỗi vị trí chúng ta cần kiểm gia trá trị để đi đến ô kế tiếp và sau đó kết nối với các hành động(action) có thể. Nếu ô bên cạnh bị chặn thì hành động sẽ được bỏ qua<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">actions</span><span class="text_13">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_13">state):<br class="calibre6" /><span class="calibre7">        actions=[]</span></span><span class="text_13"><br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">for </span><span class="text_13">action </span><span class="text_4">in </span><span class="text_13">COST.keys():<br class="calibre6" /><span class="calibre7">            newx</span></span><span class="text_4">,</span><span class="text_13">newy=</span><span class="text_10">self</span><span class="text_13">.result(state</span><span class="text_4">,</span><span class="text_13">action)<br class="calibre6" /><span class="calibre7">            </span></span><span class="text_4">if </span><span class="text_10">self</span><span class="text_13">.board[newy][newx]!=</span><span class="text_5">"#"</span><span class="text_13">:<br class="calibre6" /><span class="calibre7">                actions.append(action)</span></span><span class="text_13"><br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_13">actions<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Override method result. Dựa trên trạng thái hiện tại và hành động input, cập nhật vị trí tọa độ x và y<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">result</span><span class="text_13">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_13">state</span><span class="text_4">, </span><span class="text_13">action):<br class="calibre6" /><span class="calibre7">        x</span></span><span class="text_4">,</span><span class="text_13">y=state<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">if </span><span class="text_13">action.count(</span><span class="text_5">"up"</span><span class="text_13">):<br class="calibre6" /><span class="calibre7">            y-=</span></span><span class="text_12">1<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">if </span><span class="text_13">action.count(</span><span class="text_5">"down"</span><span class="text_13">):<br class="calibre6" /><span class="calibre7">            y+=</span></span><span class="text_12">1<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">if </span><span class="text_13">action.count(</span><span class="text_5">"left"</span><span class="text_13">):<br class="calibre6" /><span class="calibre7">            x-=</span></span><span class="text_12">1<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">if </span><span class="text_13">action.count(</span><span class="text_5">"right"</span><span class="text_13">):<br class="calibre6" /><span class="calibre7">            x+=</span></span><span class="text_12">1<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_13">new_state=(x</span><span class="text_4">,</span><span class="text_13">y)<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_13">new_state<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Kiểm tra xem đã đến đích chưa ?<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">is_goal</span><span class="text_13">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_13">state):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_13">state==</span><span class="text_10">self</span><span class="text_13">.goal<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Chúng ta định nghĩa hàm cost. đây là giá để di chuyển tới ô kế tiếp, và nó sẽ khác khi di chuyển ngang dọc và di chuyển chéo<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">cost</span><span class="text_13">(</span><span class="text_10">self</span><span class="text_4">,</span><span class="text_13">state</span><span class="text_4">,</span><span class="text_13">action</span><span class="text_4">,</span><span class="text_13">state2):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_13">COST[action]<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Giờ thì ta sử dụng hàm heuristic. Ở trường hợp này chúng ta sử dụng cách tính khoảng cách Euclidean ( tiên đề Euclidean):<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">def </span><span class="text_7">heuristic</span><span class="text_13">(</span><span class="text_10">self</span><span class="text_4">, </span><span class="text_13">state):<br class="calibre6" /><span class="calibre7">        x</span></span><span class="text_4">,</span><span class="text_13">y=state<br class="calibre6" /><span class="calibre7">        gx</span></span><span class="text_4">,</span><span class="text_13">gy=</span><span class="text_10">self</span><span class="text_13">.goal<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">return </span><span class="text_13">math.sqrt((x-gx)**</span><span class="text_12">2</span><span class="text_13">+(y-gy)**</span><span class="text_12">2</span><span class="text_13">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Định nghĩa hàm main<br class="calibre6" /></span><span class="text_4">if </span><span class="text_13">__name__==</span><span class="text_5">"__main__"</span><span class="text_13">:<br class="calibre6" /><span class="calibre7">    problem=MazeSolver(MAP)</span></span><span class="text_13"><br class="calibre6" /><span class="calibre7">    result=astar(problem</span></span><span class="text_4">,</span><span class="text_8">graph_search</span><span class="text_13">=</span><span class="text_4">True</span><span class="text_13">)<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># Xem path kết quả<br class="calibre6" /><br class="calibre6" /><br class="calibre6" /><span class="calibre7">    </span></span><span class="text_13">path=[x[</span><span class="text_12">1</span><span class="text_13">] </span><span class="text_4">for </span><span class="text_13">x </span><span class="text_4">in </span><span class="text_13">result.path()]<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_6"># In kết quả ra Terminal<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_11">print</span><span class="text_13">()<br class="calibre6" /><span class="calibre7">    </span></span><span class="text_4">for </span><span class="text_13">y </span><span class="text_4">in </span><span class="text_11">range</span><span class="text_13">(</span><span class="text_11">len</span><span class="text_13">(MAP)):<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_4">for </span><span class="text_13">x </span><span class="text_4">in </span><span class="text_11">range</span><span class="text_13">(</span><span class="text_11">len</span><span class="text_13">(MAP[y])):<br class="calibre6" /><span class="calibre7">            </span></span><span class="text_4">if</span><span class="text_13">(x</span><span class="text_4">,</span><span class="text_13">y)==problem.initial:<br class="calibre6" /><span class="calibre7">                </span></span><span class="text_11">print</span><span class="text_13">(</span><span class="text_5">'0'</span><span class="text_4">,</span><span class="text_8">end</span><span class="text_13">=</span><span class="text_5">''</span><span class="text_13">)<br class="calibre6" /><span class="calibre7">            </span></span><span class="text_4">elif</span><span class="text_13">(x</span><span class="text_4">,</span><span class="text_13">y)==problem.goal:<br class="calibre6" /><span class="calibre7">                </span></span><span class="text_11">print</span><span class="text_13">(</span><span class="text_5">'x'</span><span class="text_4">,</span><span class="text_8">end</span><span class="text_13">=</span><span class="text_5">''</span><span class="text_13">)<br class="calibre6" /><span class="calibre7">            </span></span><span class="text_4">elif</span><span class="text_13">(x</span><span class="text_4">,</span><span class="text_13">y) </span><span class="text_4">in </span><span class="text_13">path:<br class="calibre6" /><span class="calibre7">                </span></span><span class="text_11">print</span><span class="text_13">(</span><span class="text_5">'.'</span><span class="text_4">,</span><span class="text_8">end</span><span class="text_13">=</span><span class="text_5">''</span><span class="text_13">)<br class="calibre6" /><span class="calibre7">            </span></span><span class="text_4">else</span><span class="text_13">:<br class="calibre6" /><span class="calibre7">                </span></span><span class="text_11">print</span><span class="text_13">(MAP[y][x]</span><span class="text_4">,</span><span class="text_8">end</span><span class="text_13">=</span><span class="text_5">''</span><span class="text_13">)<br class="calibre6" /><span class="calibre7">        </span></span><span class="text_11">print</span><span class="text_13">()</span></p><p class="block_12"></p></div>
	<p class="block_1">Kết quả được in ra ở Terminal:</p>
	<p class="block_13">##############################</p>
	<p class="block_14"><span class="calibre7">#         #              #   #</span></p>
	<p class="block_14"><span class="calibre7"># ####    ########       #   #</span></p>
	<p class="block_14"><span class="calibre7">#  0 #    #              #   #</span></p>
	<p class="block_14"><span class="calibre7">#   .###     #####  ######   #</span></p>
	<p class="block_14"><span class="calibre7">#   .  #   ###   #  ....     #</span></p>
	<p class="block_14"><span class="calibre7">#   .  #     # ..# .#  #.  ###</span></p>
	<p class="block_14"><span class="calibre7">#    .#####   .# .. #  # x   #</span></p>
	<p class="block_14"><span class="calibre7">#     ........ #       #     #</span></p>
	<p class="block_15">##############################</p>
	<p class="block_8">&nbsp;</p>
	<p class="block_5">Tổng kết</p>
	<p class="block_1">Trong chương này chúng ta đã học về giải thuật tìm kiểm heuristic. Chúng ta đã thảo luận về sự khác nhau giữ tìm kiếm biết trước và không biết trước thông tiin. Chúng ta học về giải quyết vấn đề với những ràng buộc cần thỏa mãn. Chúng ta tìm hiểu về giải thuật local search và tại sao lại dùng giải thuật mô phỏng luyện kim (simulated annealing). Chúng ta thực hiện giải thuật tìm kiếm tham lam (greedy search) cho phép xây dựng chuỗi.Và giải quyết vấn đề với công thức CSPs( vấn đề ràng buộc cần thủa mãn).</p>
	<p class="block_1">Chúng ta đã học cách import một package với Pycharm và sử dụng thuật toán A* trong package simpleai để giải quyết nhiều bài toán giải đố như 8-puzzle hay maze-solver.</p>
	<p class="block_1">Chương tiếp theo chúng ta sẽ thảo luận về thuật toán di truyền (genetic algorithms) và cách ứng dụng nó vào thực tế.</p>

</div>

</body></html>

<footer class=" footline" >
	
</footer>


        
        </div> 
        

      </div>

    <div id="navigation">
        
        
        
        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
        
        


	 
	 
		
			<a class="nav nav-prev" href="/ai-with-python/chapter6/" title="C6: Logic Programing"> <i class="fa fa-chevron-left"></i></a>
		
		
			<a class="nav nav-next" href="/ai-with-python/chapter8/" title="C8: Thuật toán di truyền - Genetic Alogrithms" style="margin-right: 0px;"><i class="fa fa-chevron-right"></i></a>
		
	
    </div>

    </section>
    
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="/js/clipboard.min.js?1576139178"></script>
    <script src="/js/perfect-scrollbar.min.js?1576139178"></script>
    <script src="/js/perfect-scrollbar.jquery.min.js?1576139178"></script>
    <script src="/js/jquery.sticky.js?1576139178"></script>
    <script src="/js/featherlight.min.js?1576139178"></script>
    <script src="/js/highlight.pack.js?1576139178"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="/js/modernizr.custom-3.6.0.js?1576139178"></script>
    <script src="/js/learn.js?1576139178"></script>
    <script src="/js/hugo-learn.js?1576139178"></script>

    <link href="/mermaid/mermaid.css?1576139178" rel="stylesheet" />
    <script src="/mermaid/mermaid.js?1576139178"></script>
    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
    

  </body>
</html>

